<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>S312 SoftDevice v6.1.1: ANT Application Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">S312 SoftDevice
   &#160;<span id="projectnumber">v6.1.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__ant__interface.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">ANT Application Interface<div class="ingroups"><a class="el" href="group__stack__ant__module.html">ANT STACK</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>ANT Stack Application Programming Interface (API).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__ant__error"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__error.html">ANT Error Return</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__ant__parameters"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__parameters.html">ANT Stack Parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t___e_n_a_b_l_e.html">ANT_ENABLE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga05570d07c3605d3c38e1546fc0bbd2de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05570d07c3605d3c38e1546fc0bbd2de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>STK_SVC_BASE_2</b>&#160;&#160;&#160;0xC0</td></tr>
<tr class="separator:ga05570d07c3605d3c38e1546fc0bbd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br/>
&#160;&#160;<b>SVC_ANT_STACK_INIT</b> = 0xC0, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ASSIGN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_UNASSIGN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_OPEN</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_CLOSE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RX_SCAN_MODE_START</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TX_BROADCAST_MESSAGE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TX_ACKNOWLEDGED_MESSAGE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_REQUEST</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PENDING_TRANSMIT_CLEAR</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_TRANSFER_STOP</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_NETWORK_KEY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_FREQ_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_FREQ_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_RADIO_TX_POWER_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PROX_SEARCH_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_PERIOD_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_PERIOD_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ID_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_ID_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SEARCH_WAVEFORM_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_SEARCH_TIMEOUT_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SEARCH_CHANNEL_PRIORITY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE_SEARCH_SHARING_CYCLES_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE_SEARCH_SHARING_CYCLES_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_LOW_PRIO_RX_SEARCH_TIMEOUT_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ADV_BURST_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ADV_BURST_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_CLEAR</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_LIB_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ID_LIST_ADD</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ID_LIST_CONFIG</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_AUTO_FREQ_HOP_TABLE_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_FILTERING_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EVENT_FILTERING_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ACTIVE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_IN_PROGRESS</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CHANNEL_STATUS_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_PENDING_TRANSMIT</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_INIT_CW_TEST_MODE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CW_TEST_MODE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_VERSION</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CAPABILITIES</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_WAIT_FLAG_ENABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_BURST_HANDLER_WAIT_FLAG_DISABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_SDU_MASK_CONFIG</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_CHANNEL_ENABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_KEY_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_INFO_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_CRYPTO_INFO_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RFACTIVE_NOTIFICATION_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RFACTIVE_NOTIFICATION_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_COEX_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_COEX_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_ENABLE</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RESERVED1</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_RESERVED2</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED0</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED1</b>, 
<br/>
&#160;&#160;<b>SVC_ANT_EXTENDED2</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANT Stack API SVC numbers. <br/></td></tr>
<tr class="separator:ga06fc87d81c62e9abb8790b6e5713c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bc71425ddb7a71e09d9c4db310f2469"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga3bc71425ddb7a71e09d9c4db310f2469">EXT0_ID</a> { <br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_WAKEON_RF_ACTIVITY_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_ENHANCED_CHANNEL_SPACING_ENABLE</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_RESERVED_0</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_RESERVED_1</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_TIME_STAMP_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_TIME_STAMP_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_TIME_SYNC_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_TIME_SYNC_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_TIME_SYNC_MESSAGE</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_HDS_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_HDS_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_PA_LNA_CONFIG_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_PA_LNA_CONFIG_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_CHANNEL_RADIO_CRC_MODE_SET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_CHANNEL_RADIO_CRC_MODE_GET</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_RESERVED_2</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_RESERVED_3</b>, 
<br/>
&#160;&#160;<b>SD_ANT_EXT0_ID_SEARCH_CHANNEL_PRIORITY_GET</b>
<br/>
 }</td></tr>
<tr class="memdesc:ga3bc71425ddb7a71e09d9c4db310f2469"><td class="mdescLeft">&#160;</td><td class="mdescRight">ANT Stack API Extended 0 SVC call numbers. <br/></td></tr>
<tr class="separator:ga3bc71425ddb7a71e09d9c4db310f2469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
ANT API functions</h2></td></tr>
<tr class="memitem:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga38b44d71b463cfd0d12fa07b63191d9f">sd_ant_stack_reset</a> (void)</td></tr>
<tr class="memdesc:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for resetting the ANT Stack. This is a blocking operation. If the operation has timed out (after ~2 seconds), then NRF_ERROR_TIMEOUT is returned and the application must try again. Otherwise, upon successful reset, NRF_SUCCESS is returned.  <a href="#ga38b44d71b463cfd0d12fa07b63191d9f">More...</a><br/></td></tr>
<tr class="separator:ga38b44d71b463cfd0d12fa07b63191d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga871ce84112f0aa7dc40468a7d6b3fdbd">sd_ant_event_get</a> (uint8_t *pucChannel, uint8_t *pucEvent, uint8_t *aucANTMesg)</td></tr>
<tr class="memdesc:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns ANT channel events and data messages.  <a href="#ga871ce84112f0aa7dc40468a7d6b3fdbd">More...</a><br/></td></tr>
<tr class="separator:ga871ce84112f0aa7dc40468a7d6b3fdbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee008ec03098a855dd200c9cec28854"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga0ee008ec03098a855dd200c9cec28854">sd_ant_channel_assign</a> (uint8_t ucChannel, uint8_t ucChannelType, uint8_t ucNetwork, uint8_t ucExtAssign)</td></tr>
<tr class="memdesc:ga0ee008ec03098a855dd200c9cec28854"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns and initializes a new channel.  <a href="#ga0ee008ec03098a855dd200c9cec28854">More...</a><br/></td></tr>
<tr class="separator:ga0ee008ec03098a855dd200c9cec28854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe35f6cb447e86746361f1411953c171"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gafe35f6cb447e86746361f1411953c171">sd_ant_channel_unassign</a> (uint8_t ucChannel)</td></tr>
<tr class="memdesc:gafe35f6cb447e86746361f1411953c171"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unassigns a channel. The channel to unassign must be in an assigned state.  <a href="#gafe35f6cb447e86746361f1411953c171">More...</a><br/></td></tr>
<tr class="separator:gafe35f6cb447e86746361f1411953c171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ad1f93f99f0767907d21c278e04eea8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ad1f93f99f0767907d21c278e04eea8"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>sd_ant_channel_open_with_offset</b> (uint8_t ucChannel, uint16_t usOffset)</td></tr>
<tr class="separator:ga3ad1f93f99f0767907d21c278e04eea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b069b1d3147d0bcac9505efa60dea6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gad6b069b1d3147d0bcac9505efa60dea6">sd_ant_channel_close</a> (uint8_t ucChannel)</td></tr>
<tr class="memdesc:gad6b069b1d3147d0bcac9505efa60dea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function closes a channel. The channel must be in an open state (SEARCHING or TRACKING).  <a href="#gad6b069b1d3147d0bcac9505efa60dea6">More...</a><br/></td></tr>
<tr class="separator:gad6b069b1d3147d0bcac9505efa60dea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafafa38f71054778becea049bc3ada46"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaafafa38f71054778becea049bc3ada46">sd_ant_rx_scan_mode_start</a> (uint8_t ucSyncChannelPacketsOnly)</td></tr>
<tr class="memdesc:gaafafa38f71054778becea049bc3ada46"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts receive scanning mode feature. Channel 0 must be assigned. All other channels must be closed.  <a href="#gaafafa38f71054778becea049bc3ada46">More...</a><br/></td></tr>
<tr class="separator:gaafafa38f71054778becea049bc3ada46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga2e48883c0e50c1c380b61fd0c28b3879">sd_ant_broadcast_message_tx</a> (uint8_t ucChannel, uint8_t ucSize, uint8_t *aucMesg)</td></tr>
<tr class="memdesc:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to set broadcast data for transmission.  <a href="#ga2e48883c0e50c1c380b61fd0c28b3879">More...</a><br/></td></tr>
<tr class="separator:ga2e48883c0e50c1c380b61fd0c28b3879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893d871362f4eaf1e82a6749af27136b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga893d871362f4eaf1e82a6749af27136b">sd_ant_acknowledge_message_tx</a> (uint8_t ucChannel, uint8_t ucSize, uint8_t *aucMesg)</td></tr>
<tr class="memdesc:ga893d871362f4eaf1e82a6749af27136b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send an acknowledge message. This message requests an acknowledgement from the slave to validate reception.  <a href="#ga893d871362f4eaf1e82a6749af27136b">More...</a><br/></td></tr>
<tr class="separator:ga893d871362f4eaf1e82a6749af27136b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa09761cfc5e7373048e90e2dca208e6a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaa09761cfc5e7373048e90e2dca208e6a">sd_ant_burst_handler_request</a> (uint8_t ucChannel, uint16_t usSize, uint8_t *aucData, uint8_t ucBurstSegment)</td></tr>
<tr class="memdesc:gaa09761cfc5e7373048e90e2dca208e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to queue data for burst transmission. After every successful call, the input buffer is held in use by the burst handler and must not be changed. When the burst handler releases the input buffer, it will either generate a <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> event or clear a specified wait flag assigned to the burst handler. Transfer end events: <a class="el" href="group__ant__parameters.html#ga51573152c1529ee27fed45e93372728f">EVENT_TRANSFER_TX_COMPLETED</a> and <a class="el" href="group__ant__parameters.html#gaf9f5a3fd4304ebae7e61e6ce78fed2b9">EVENT_TRANSFER_TX_FAILED</a> also releases the input buffer. Special care must be made to ensure that the input buffer does not change until it is released by the burst handler to avoid data corruption. Use of burst segment identifiers (<a class="el" href="group__ant__parameters.html#ga37b944eb5dc2a7468e5a347bbb91e836">BURST_SEGMENT_START</a>, <a class="el" href="group__ant__parameters.html#ga56e39155014fde638f41df68325db77f">BURST_SEGMENT_CONTINUE</a>, and <a class="el" href="group__ant__parameters.html#ga113c56011fdb29743c5b46bd938098f0">BURST_SEGMENT_END</a>) is required to indicate the sequence of the data block being sent as a burst transfer.  <a href="#gaa09761cfc5e7373048e90e2dca208e6a">More...</a><br/></td></tr>
<tr class="separator:gaa09761cfc5e7373048e90e2dca208e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga93a4111cc6e4b75e3b6b4d665937e625">sd_ant_pending_transmit_clear</a> (uint8_t ucChannel, uint8_t *pucSuccess)</td></tr>
<tr class="memdesc:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears a pending transmit. Primarily intended for shared slave channels (receive channel).  <a href="#ga93a4111cc6e4b75e3b6b4d665937e625">More...</a><br/></td></tr>
<tr class="separator:ga93a4111cc6e4b75e3b6b4d665937e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59fb0d7717ce7e81a0adecd247511b17"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga59fb0d7717ce7e81a0adecd247511b17">sd_ant_transfer_stop</a> (void)</td></tr>
<tr class="memdesc:ga59fb0d7717ce7e81a0adecd247511b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function kills a receive transfer that is in progress.  <a href="#ga59fb0d7717ce7e81a0adecd247511b17">More...</a><br/></td></tr>
<tr class="separator:ga59fb0d7717ce7e81a0adecd247511b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a05168143a2c54efb138eeaf74a6e18"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga4a05168143a2c54efb138eeaf74a6e18">sd_ant_network_address_set</a> (uint8_t ucNetwork, const uint8_t *aucNetworkKey)</td></tr>
<tr class="memdesc:ga4a05168143a2c54efb138eeaf74a6e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the 64bit network address.  <a href="#ga4a05168143a2c54efb138eeaf74a6e18">More...</a><br/></td></tr>
<tr class="separator:ga4a05168143a2c54efb138eeaf74a6e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga28b87b0df8a35fe5e8ffb23e7bd89967">sd_ant_channel_radio_freq_set</a> (uint8_t ucChannel, uint8_t ucFreq)</td></tr>
<tr class="memdesc:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the radio frequency of an ANT channel.  <a href="#ga28b87b0df8a35fe5e8ffb23e7bd89967">More...</a><br/></td></tr>
<tr class="separator:ga28b87b0df8a35fe5e8ffb23e7bd89967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga874e9c551db1f3297a0253c5142106bf"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga874e9c551db1f3297a0253c5142106bf">sd_ant_channel_radio_freq_get</a> (uint8_t ucChannel, uint8_t *pucRfreq)</td></tr>
<tr class="memdesc:ga874e9c551db1f3297a0253c5142106bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the radio frequency of an ANT channel.  <a href="#ga874e9c551db1f3297a0253c5142106bf">More...</a><br/></td></tr>
<tr class="separator:ga874e9c551db1f3297a0253c5142106bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70e472a2603eb90c0a6a8af71e764135"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga70e472a2603eb90c0a6a8af71e764135">sd_ant_channel_radio_tx_power_set</a> (uint8_t ucChannel, uint8_t ucTxPower, uint8_t ucCustomTxPower)</td></tr>
<tr class="memdesc:ga70e472a2603eb90c0a6a8af71e764135"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the radio tx power.  <a href="#ga70e472a2603eb90c0a6a8af71e764135">More...</a><br/></td></tr>
<tr class="separator:ga70e472a2603eb90c0a6a8af71e764135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga06b245376f5a6a1b1cc3eb747b12a245">sd_ant_prox_search_set</a> (uint8_t ucChannel, uint8_t ucProxThreshold, uint8_t ucCustomProxThreshold)</td></tr>
<tr class="memdesc:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensitivity threshold for acquisition on a searching channel. One time set.  <a href="#ga06b245376f5a6a1b1cc3eb747b12a245">More...</a><br/></td></tr>
<tr class="separator:ga06b245376f5a6a1b1cc3eb747b12a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga5f02ffc719c4589cc7943d6fb67f34e0">sd_ant_channel_period_set</a> (uint8_t ucChannel, uint16_t usPeriod)</td></tr>
<tr class="memdesc:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel period.  <a href="#ga5f02ffc719c4589cc7943d6fb67f34e0">More...</a><br/></td></tr>
<tr class="separator:ga5f02ffc719c4589cc7943d6fb67f34e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gad101863c3a594c0a05d6bdb20dc82d0d">sd_ant_channel_period_get</a> (uint8_t ucChannel, uint16_t *pusPeriod)</td></tr>
<tr class="memdesc:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current channel period.  <a href="#gad101863c3a594c0a05d6bdb20dc82d0d">More...</a><br/></td></tr>
<tr class="separator:gad101863c3a594c0a05d6bdb20dc82d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gac19f4abd3e4d46b4b2f8f0397aa9c113">sd_ant_channel_id_set</a> (uint8_t ucChannel, uint16_t usDeviceNumber, uint8_t ucDeviceType, uint8_t ucTransmitType)</td></tr>
<tr class="memdesc:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel ID.  <a href="#gac19f4abd3e4d46b4b2f8f0397aa9c113">More...</a><br/></td></tr>
<tr class="separator:gac19f4abd3e4d46b4b2f8f0397aa9c113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gafcb9a891d63281d8e018ea923d6e6dc5">sd_ant_channel_id_get</a> (uint8_t ucChannel, uint16_t *pusDeviceNumber, uint8_t *pucDeviceType, uint8_t *pucTransmitType)</td></tr>
<tr class="memdesc:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the current Channel ID of a channel.  <a href="#gafcb9a891d63281d8e018ea923d6e6dc5">More...</a><br/></td></tr>
<tr class="separator:gafcb9a891d63281d8e018ea923d6e6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4de80c986c5f0be170c850ea50a639a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaf4de80c986c5f0be170c850ea50a639a">sd_ant_search_waveform_set</a> (uint8_t ucChannel, uint16_t usWaveform)</td></tr>
<tr class="memdesc:gaf4de80c986c5f0be170c850ea50a639a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the searching waveform value of an ANT Channel.  <a href="#gaf4de80c986c5f0be170c850ea50a639a">More...</a><br/></td></tr>
<tr class="separator:gaf4de80c986c5f0be170c850ea50a639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70886a25cee80d457e3fb68f6cfc3182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70886a25cee80d457e3fb68f6cfc3182"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>sd_ant_channel_search_timeout_set</b> (uint8_t ucChannel, uint8_t ucTimeout)</td></tr>
<tr class="separator:ga70886a25cee80d457e3fb68f6cfc3182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3020bbb168a16049a94e39f3742a96e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga3020bbb168a16049a94e39f3742a96e2">sd_ant_search_channel_priority_set</a> (uint8_t ucChannel, uint8_t ucSearchPriority)</td></tr>
<tr class="memdesc:ga3020bbb168a16049a94e39f3742a96e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel's search priority.  <a href="#ga3020bbb168a16049a94e39f3742a96e2">More...</a><br/></td></tr>
<tr class="separator:ga3020bbb168a16049a94e39f3742a96e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533dff69abced3e86d35e026b1b3f2e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga533dff69abced3e86d35e026b1b3f2e1">sd_ant_active_search_sharing_cycles_set</a> (uint8_t ucChannel, uint8_t ucCycles)</td></tr>
<tr class="memdesc:ga533dff69abced3e86d35e026b1b3f2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the search cycle number of separate searching channels for active search time sharing.  <a href="#ga533dff69abced3e86d35e026b1b3f2e1">More...</a><br/></td></tr>
<tr class="separator:ga533dff69abced3e86d35e026b1b3f2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d681d85ad32f768f4cb0139f4625d34"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga5d681d85ad32f768f4cb0139f4625d34">sd_ant_active_search_sharing_cycles_get</a> (uint8_t ucChannel, uint8_t *pucCycles)</td></tr>
<tr class="memdesc:ga5d681d85ad32f768f4cb0139f4625d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the search sharing cycles number of the specified searching channel for active search time sharing.  <a href="#ga5d681d85ad32f768f4cb0139f4625d34">More...</a><br/></td></tr>
<tr class="separator:ga5d681d85ad32f768f4cb0139f4625d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc75068807b29d6cd80266309536b605"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gafc75068807b29d6cd80266309536b605">sd_ant_channel_low_priority_rx_search_timeout_set</a> (uint8_t ucChannel, uint8_t ucTimeout)</td></tr>
<tr class="memdesc:gafc75068807b29d6cd80266309536b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the low priority search timeout value of a channel.  <a href="#gafc75068807b29d6cd80266309536b605">More...</a><br/></td></tr>
<tr class="separator:gafc75068807b29d6cd80266309536b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4919de32f0122fc9ec57e282ee7fece0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga4919de32f0122fc9ec57e282ee7fece0">sd_ant_adv_burst_config_set</a> (uint8_t *aucConfig, uint8_t ucSize)</td></tr>
<tr class="memdesc:ga4919de32f0122fc9ec57e282ee7fece0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the advanced burst configuration. Configuration structure is as follows: Required Byte0 = 0-Disable, 1-Enable. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte1 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte2 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte3 = 0, Reserved Required Byte4 = 0, Reserved Required Byte5 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte6 = 0, Reserved Required Byte7 = 0, Reserved Optional Byte8 = Advanced burst stalling count config LSB. Typical is 3210 (~10s of stalling) where each count represents ~3ms of stalling. Optional Byte9 = Advanced burst stalling count config MSB. Optional Byte10 = Advanced burst retry count cycle extension. Typical is 3 (15 retries) where each count cycles represents 5 retries.  <a href="#ga4919de32f0122fc9ec57e282ee7fece0">More...</a><br/></td></tr>
<tr class="separator:ga4919de32f0122fc9ec57e282ee7fece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff68f0ee4408c590755914e40a2ff64"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga6ff68f0ee4408c590755914e40a2ff64">sd_ant_adv_burst_config_get</a> (uint8_t ucRequestType, uint8_t *aucConfig)</td></tr>
<tr class="memdesc:ga6ff68f0ee4408c590755914e40a2ff64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the advance burst configuration and supported capabilities. Returned structure is as follows for configuration: Byte0 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h. Byte1 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Byte2 = 0, Reserved Byte3 = 0, Reserved Byte4 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Byte5 = 0, Reserved Byte6 = 0, Reserved Byte7 = Advanced burst stalling count config LSB. Each count represents ~3ms of stalling. Byte8 = Advanced burst stalling count config MSB Byte9 = Advanced burst retry count cycle extension. Each count cycle represents 5 retries.  <a href="#ga6ff68f0ee4408c590755914e40a2ff64">More...</a><br/></td></tr>
<tr class="separator:ga6ff68f0ee4408c590755914e40a2ff64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaf75d7ef14fd9efe9fbad3f1892fd5c74">sd_ant_lib_config_set</a> (uint8_t ucANTLibConfig)</td></tr>
<tr class="memdesc:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the ANT Messaging Library Configuration used by Extended messaging.  <a href="#gaf75d7ef14fd9efe9fbad3f1892fd5c74">More...</a><br/></td></tr>
<tr class="separator:gaf75d7ef14fd9efe9fbad3f1892fd5c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga67109fc1c0cb71cb88976d554ae3cd5d">sd_ant_lib_config_clear</a> (uint8_t ucANTLibConfig)</td></tr>
<tr class="memdesc:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function clears the ANT Messaging Library Configuration.  <a href="#ga67109fc1c0cb71cb88976d554ae3cd5d">More...</a><br/></td></tr>
<tr class="separator:ga67109fc1c0cb71cb88976d554ae3cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga5044f2aea53e57eb113fc8f4afd02b6a">sd_ant_lib_config_get</a> (uint8_t *pucANTLibConfig)</td></tr>
<tr class="memdesc:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns current ANT Messaging Library Configuration.  <a href="#ga5044f2aea53e57eb113fc8f4afd02b6a">More...</a><br/></td></tr>
<tr class="separator:ga5044f2aea53e57eb113fc8f4afd02b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gadc8dd07669424ef4e30dfaa75fa00a82">sd_ant_id_list_add</a> (uint8_t ucChannel, uint8_t *aucDevId, uint8_t ucListIndex)</td></tr>
<tr class="memdesc:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to add a Device ID to an include or exclude list.  <a href="#gadc8dd07669424ef4e30dfaa75fa00a82">More...</a><br/></td></tr>
<tr class="separator:gadc8dd07669424ef4e30dfaa75fa00a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf8ece10c4b90f397fac9f760408c64"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaeaf8ece10c4b90f397fac9f760408c64">sd_ant_id_list_config</a> (uint8_t ucChannel, uint8_t ucIDListSize, uint8_t ucIncExcFlag)</td></tr>
<tr class="memdesc:gaeaf8ece10c4b90f397fac9f760408c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to configure the device ID list as include or exclude as well as the number of IDs to compare against.  <a href="#gaeaf8ece10c4b90f397fac9f760408c64">More...</a><br/></td></tr>
<tr class="separator:gaeaf8ece10c4b90f397fac9f760408c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190f13a6952b372514157011766b68ac"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga190f13a6952b372514157011766b68ac">sd_ant_auto_freq_hop_table_set</a> (uint8_t ucChannel, uint8_t ucFreq0, uint8_t ucFreq1, uint8_t ucFreq2)</td></tr>
<tr class="memdesc:ga190f13a6952b372514157011766b68ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function populates the frequency hop table list. This table is used when frequency hopping is enabled on a channel via extended assignment bit.  <a href="#ga190f13a6952b372514157011766b68ac">More...</a><br/></td></tr>
<tr class="separator:ga190f13a6952b372514157011766b68ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cbb544dccb5be899079effe993db66"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gab7cbb544dccb5be899079effe993db66">sd_ant_event_filtering_set</a> (uint16_t usFilter)</td></tr>
<tr class="memdesc:gab7cbb544dccb5be899079effe993db66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to specify filter configuration for channel event message generation.  <a href="#gab7cbb544dccb5be899079effe993db66">More...</a><br/></td></tr>
<tr class="separator:gab7cbb544dccb5be899079effe993db66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga9297eb25b36a2cc0c6a221a3df9bd4a8">sd_ant_event_filtering_get</a> (uint16_t *pusFilter)</td></tr>
<tr class="memdesc:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to retrieve the filter configuration for channel event message generation.  <a href="#ga9297eb25b36a2cc0c6a221a3df9bd4a8">More...</a><br/></td></tr>
<tr class="separator:ga9297eb25b36a2cc0c6a221a3df9bd4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a52294fb19c558b644c09af9834995d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga8a52294fb19c558b644c09af9834995d">sd_ant_active</a> (uint8_t *pbAntActive)</td></tr>
<tr class="memdesc:ga8a52294fb19c558b644c09af9834995d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the ANT activity status.  <a href="#ga8a52294fb19c558b644c09af9834995d">More...</a><br/></td></tr>
<tr class="separator:ga8a52294fb19c558b644c09af9834995d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gab50ecb72e0edd83d1e8e11e50f17a210">sd_ant_channel_in_progress</a> (uint8_t *pbChannelInProgress)</td></tr>
<tr class="memdesc:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the status if the channel is in progress.  <a href="#gab50ecb72e0edd83d1e8e11e50f17a210">More...</a><br/></td></tr>
<tr class="separator:gab50ecb72e0edd83d1e8e11e50f17a210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc5a64712fcf2117071a5136cc976f8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaddc5a64712fcf2117071a5136cc976f8">sd_ant_channel_status_get</a> (uint8_t ucChannel, uint8_t *pucStatus)</td></tr>
<tr class="memdesc:gaddc5a64712fcf2117071a5136cc976f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets a specific channel's status.  <a href="#gaddc5a64712fcf2117071a5136cc976f8">More...</a><br/></td></tr>
<tr class="separator:gaddc5a64712fcf2117071a5136cc976f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga2c0e2144ea9c33340c3ee660eef0ebec">sd_ant_pending_transmit</a> (uint8_t ucChannel, uint8_t *pucPending)</td></tr>
<tr class="memdesc:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function determines if there is a pending transmission on a specific channel.  <a href="#ga2c0e2144ea9c33340c3ee660eef0ebec">More...</a><br/></td></tr>
<tr class="separator:ga2c0e2144ea9c33340c3ee660eef0ebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb311b7dfbb4457119e5144de9008a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga0bb311b7dfbb4457119e5144de9008a7">sd_ant_cw_test_mode_init</a> (void)</td></tr>
<tr class="memdesc:ga0bb311b7dfbb4457119e5144de9008a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initialize the stack to get ready for a continuous wave transmission test.  <a href="#ga0bb311b7dfbb4457119e5144de9008a7">More...</a><br/></td></tr>
<tr class="separator:ga0bb311b7dfbb4457119e5144de9008a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac67e3eba7d08bcf6250db7388ca36641"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gac67e3eba7d08bcf6250db7388ca36641">sd_ant_cw_test_mode</a> (uint8_t ucRadioFreq, uint8_t ucTxPower, uint8_t ucCustomTxPower, uint8_t ucMode)</td></tr>
<tr class="memdesc:gac67e3eba7d08bcf6250db7388ca36641"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function starts a continuous wave test mode transmission.  <a href="#gac67e3eba7d08bcf6250db7388ca36641">More...</a><br/></td></tr>
<tr class="separator:gac67e3eba7d08bcf6250db7388ca36641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga529f053ac81ed70c97ade5a8ee7ddb4f">sd_ant_version_get</a> (uint8_t *aucVersion)</td></tr>
<tr class="memdesc:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the version string of the ANT stack.  <a href="#ga529f053ac81ed70c97ade5a8ee7ddb4f">More...</a><br/></td></tr>
<tr class="separator:ga529f053ac81ed70c97ade5a8ee7ddb4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ae3c048f41006e2beb531a5e875385d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga6ae3c048f41006e2beb531a5e875385d">sd_ant_capabilities_get</a> (uint8_t *aucCapabilities)</td></tr>
<tr class="memdesc:ga6ae3c048f41006e2beb531a5e875385d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the capabilities of the stack.  <a href="#ga6ae3c048f41006e2beb531a5e875385d">More...</a><br/></td></tr>
<tr class="separator:ga6ae3c048f41006e2beb531a5e875385d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9555406ba64e0005d0ae57e346910026"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga9555406ba64e0005d0ae57e346910026">sd_ant_burst_handler_wait_flag_enable</a> (uint8_t *pucWaitFlag)</td></tr>
<tr class="memdesc:ga9555406ba64e0005d0ae57e346910026"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a wait variable to the the burst handler. When the input buffer is locked by the handler the wait flag is set to 1. When the input buffer is unlocked, the wait flag is set to 0. When a wait flag is assigned, <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> events will not be generated until the wait flag unassigned. The wait flag should be declared as a static variable.  <a href="#ga9555406ba64e0005d0ae57e346910026">More...</a><br/></td></tr>
<tr class="separator:ga9555406ba64e0005d0ae57e346910026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gab4cc4eb62a0b01c7bdc2b235e4417184">sd_ant_burst_handler_wait_flag_disable</a> (void)</td></tr>
<tr class="memdesc:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function unassigns any previously assigned wait variable from the burst handler. The burst handler returns to the default method in generating <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> to indicate input buffer unlock.  <a href="#gab4cc4eb62a0b01c7bdc2b235e4417184">More...</a><br/></td></tr>
<tr class="separator:gab4cc4eb62a0b01c7bdc2b235e4417184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga231d8b588e95f769b07b6fbdd879d439"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga231d8b588e95f769b07b6fbdd879d439">sd_ant_sdu_mask_set</a> (uint8_t ucMask, uint8_t *aucMask)</td></tr>
<tr class="memdesc:ga231d8b588e95f769b07b6fbdd879d439"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to assign a selective data update (SDU) mask (8 octets) to an identifier, ucMask.  <a href="#ga231d8b588e95f769b07b6fbdd879d439">More...</a><br/></td></tr>
<tr class="separator:ga231d8b588e95f769b07b6fbdd879d439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b975a9f6539705f63863d11d8ca4f23"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga9b975a9f6539705f63863d11d8ca4f23">sd_ant_sdu_mask_get</a> (uint8_t ucMask, uint8_t *aucMask)</td></tr>
<tr class="memdesc:ga9b975a9f6539705f63863d11d8ca4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns the selective data update (SDU) mask (8 octets) from the specified identifier, ucMask.  <a href="#ga9b975a9f6539705f63863d11d8ca4f23">More...</a><br/></td></tr>
<tr class="separator:ga9b975a9f6539705f63863d11d8ca4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23878b31b61d3314ed4a315a55afca90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga23878b31b61d3314ed4a315a55afca90">sd_ant_sdu_mask_config</a> (uint8_t ucChannel, uint8_t ucMaskConfig)</td></tr>
<tr class="memdesc:ga23878b31b61d3314ed4a315a55afca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a SDU mask configuration to a particular channel. The configuration specifies the mask identifier and the type of rx data in which the mask should be applied to.  <a href="#ga23878b31b61d3314ed4a315a55afca90">More...</a><br/></td></tr>
<tr class="separator:ga23878b31b61d3314ed4a315a55afca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga1d633f9ec84b9a81063dbb29ad675ed1">sd_ant_crypto_channel_enable</a> (uint8_t ucChannel, uint8_t ucEnable, uint8_t ucKeyNum, uint8_t ucDecimationRate)</td></tr>
<tr class="memdesc:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables 128-bit AES encryption mode to the specified channel. Advanced burst must be enabled beforehand to enable encrypted channel.  <a href="#ga1d633f9ec84b9a81063dbb29ad675ed1">More...</a><br/></td></tr>
<tr class="separator:ga1d633f9ec84b9a81063dbb29ad675ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaf590fd95860473bdd4a99f91443453"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gabaf590fd95860473bdd4a99f91443453">sd_ant_crypto_key_set</a> (uint8_t ucKeyNum, uint8_t *aucKey)</td></tr>
<tr class="memdesc:gabaf590fd95860473bdd4a99f91443453"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assigns a 128-bit AES encryption key to a key index.  <a href="#gabaf590fd95860473bdd4a99f91443453">More...</a><br/></td></tr>
<tr class="separator:gabaf590fd95860473bdd4a99f91443453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b1c52c190dd267646f9968488c6c3f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga04b1c52c190dd267646f9968488c6c3f">sd_ant_crypto_info_set</a> (uint8_t ucType, uint8_t *aucInfo)</td></tr>
<tr class="memdesc:ga04b1c52c190dd267646f9968488c6c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation.  <a href="#ga04b1c52c190dd267646f9968488c6c3f">More...</a><br/></td></tr>
<tr class="separator:ga04b1c52c190dd267646f9968488c6c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f62c111be73ea126866e9d097a1480"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga84f62c111be73ea126866e9d097a1480">sd_ant_crypto_info_get</a> (uint8_t ucType, uint8_t *aucInfo)</td></tr>
<tr class="memdesc:ga84f62c111be73ea126866e9d097a1480"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation.  <a href="#ga84f62c111be73ea126866e9d097a1480">More...</a><br/></td></tr>
<tr class="separator:ga84f62c111be73ea126866e9d097a1480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga74d5df5b5e66bf6d40b283e80842c0c5">sd_ant_rfactive_notification_config_set</a> (uint8_t ucMode, uint16_t usTimeThreshold)</td></tr>
<tr class="memdesc:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables/disables event notifications to be generated to the application indicating the time to the next ANT radio activity exceeds the configured time threshold. Latency (delay in event notification being received and processed by application) must be taken into account if attempting to use this generated event to perform operations prior to the radio activity. Cannot be used if asynchronous tx channel is assigned or used. Please note that this only generates events for ANT radio activity.  <a href="#ga74d5df5b5e66bf6d40b283e80842c0c5">More...</a><br/></td></tr>
<tr class="separator:ga74d5df5b5e66bf6d40b283e80842c0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa66114d4387791c8b4b20317698d6cb1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaa66114d4387791c8b4b20317698d6cb1">sd_ant_rfactive_notification_config_get</a> (uint8_t *pucMode, uint16_t *pusTimeThreshold)</td></tr>
<tr class="memdesc:gaa66114d4387791c8b4b20317698d6cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the ANT rf active notification configuration.  <a href="#gaa66114d4387791c8b4b20317698d6cb1">More...</a><br/></td></tr>
<tr class="separator:gaa66114d4387791c8b4b20317698d6cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4a252715e30105ba3f2f72165b5630"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga2e4a252715e30105ba3f2f72165b5630">sd_ant_coex_config_set</a> (uint8_t ucChannel, <a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *pstCoexConfig, <a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *pstAdvCoexConfig)</td></tr>
<tr class="memdesc:ga2e4a252715e30105ba3f2f72165b5630"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets ANT radio coexistence behaviour. Supported only if ANT is sharing radio HW concurrently with another wireless protocol. Configuration structure is as follows: Byte0 = Configuration enable bitfield bit0 - enable/disable tx/rx channel keep alive config (Byte4/5 &amp; Byte6/7) bit1 - enable/disable tx/rx channel fixed interval priority config (Byte1) bit2 - enable/disable transfer keep alive config (Byte2) bit3 - enable/disable search channel fixed interval priority config (Byte3) else - reserved Byte1 = tx/rx channel fixed interval priority configuration Byte2 = transfer keep alive configuration Byte3 = search channel fixed interval priority configuration Byte4(LSB)/Byte5(MSB) = tx channel keep alive configuration Byte6(LSB)/Byte7(MSB) = rx channel keep alive configuration Byte8 = ANT counts/16 spent in high priority mode during search scan. Byte9 = ANT counts/16 spent in low priority mode during search scan.  <a href="#ga2e4a252715e30105ba3f2f72165b5630">More...</a><br/></td></tr>
<tr class="separator:ga2e4a252715e30105ba3f2f72165b5630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa7782d6fcedf0de409c004ce88f1b36"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gafa7782d6fcedf0de409c004ce88f1b36">sd_ant_coex_config_get</a> (uint8_t ucChannel, <a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *pstCoexConfig, <a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *pstAdvCoexConfig)</td></tr>
<tr class="memdesc:gafa7782d6fcedf0de409c004ce88f1b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the configured ANT radio coexistence behaviour as described in ant_coex_config_set.  <a href="#gafa7782d6fcedf0de409c004ce88f1b36">More...</a><br/></td></tr>
<tr class="separator:gafa7782d6fcedf0de409c004ce88f1b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac890b37f9e3e5f7ef08add20117dd3ad"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gac890b37f9e3e5f7ef08add20117dd3ad">sd_ant_enable</a> (<a class="el" href="struct_a_n_t___e_n_a_b_l_e.html">ANT_ENABLE</a> *const pstChannelEnable)</td></tr>
<tr class="memdesc:gac890b37f9e3e5f7ef08add20117dd3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to specify the total number of ANT channels, number of encrypted channels (subset of total ANT channels) and transmit burst queue size to be supported by the ANT stack. Upon enabling the SoftDevice successfully, the ANT stack defaults to supporting 1 ANT channel (encryption capable) and a 64 byte transmit burst buffer. If additional channels are needed and/or more encrypted channels are needed and/or larger tx burst buffer size is needed, then the desired configuration can be specified to the SoftDevice using this function. In this case, a static RAM buffer (of minimum size defined by <a class="el" href="group__ant__parameters.html#gaf53cab067ff8c0fed43823a1ceebd701">ANT_ENABLE_GET_REQUIRED_SPACE</a>) must be supplied by the application to be used by the ANT SoftDevice stack.  <a href="#gac890b37f9e3e5f7ef08add20117dd3ad">More...</a><br/></td></tr>
<tr class="separator:gac890b37f9e3e5f7ef08add20117dd3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae19a46dbb68569e329be746299bdd96a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gae19a46dbb68569e329be746299bdd96a">sd_ant_extended0</a> (uint32_t ucExtID, void *pvArg0, void *pvArg1, void *pvArg2)</td></tr>
<tr class="memdesc:gae19a46dbb68569e329be746299bdd96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended0 ANT SVCs. Access extended SVC functions via ucExtID.  <a href="#gae19a46dbb68569e329be746299bdd96a">More...</a><br/></td></tr>
<tr class="separator:gae19a46dbb68569e329be746299bdd96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a8ed9bce422370f99b312a7c6e6580"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaa5a8ed9bce422370f99b312a7c6e6580">sd_ant_wakeon_rf_activity_config_set</a> (uint8_t ucWakeupConfig)</td></tr>
<tr class="memdesc:gaa5a8ed9bce422370f99b312a7c6e6580"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function configures CPU wake on ANT RF activity behaviour. CPU is woken up via generation of SD_EVENT_IRQn interrupt upon the start of specified RF activity. In order to wakeup in the event that SD_EVENT_IRQn is disabled, the SEVONPEND flag has to be set in the Cortex-M0 System Control Register (SCR). CPU is dissallowed from entering low power state when calling sd_app_event_wait() for the duration of the RF activity. The intention of this function is to allow/disallow sudden shifts in current consumption during RF transmission/ RF reception window which may impact RF performance. When enabled there is a slight increase in average current consumption for ANT activities.  <a href="#gaa5a8ed9bce422370f99b312a7c6e6580">More...</a><br/></td></tr>
<tr class="separator:gaa5a8ed9bce422370f99b312a7c6e6580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa08965193dd425a1bbee4d8209766da6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaa08965193dd425a1bbee4d8209766da6">sd_ant_wakeon_rf_activity_config_get</a> (uint8_t *ucWakeupConfig)</td></tr>
<tr class="memdesc:gaa08965193dd425a1bbee4d8209766da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function retrieves the configured CPU wake on ANT RF activity behaviour.  <a href="#gaa08965193dd425a1bbee4d8209766da6">More...</a><br/></td></tr>
<tr class="separator:gaa08965193dd425a1bbee4d8209766da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f53a10a2c7c7e4b2a392a09e7576f8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga64f53a10a2c7c7e4b2a392a09e7576f8">sd_ant_enhanced_channel_spacing_enable</a> (uint8_t ucEnable)</td></tr>
<tr class="memdesc:ga64f53a10a2c7c7e4b2a392a09e7576f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function enables or disables the enhanced channel spacing feature. This feature is enabled by default and is used to reduce internal channel collisions when running multiple tracking channels with channel periods that are synchronous with each other.  <a href="#ga64f53a10a2c7c7e4b2a392a09e7576f8">More...</a><br/></td></tr>
<tr class="separator:ga64f53a10a2c7c7e4b2a392a09e7576f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ea3f4c4c7e0ac2ededda62ba66598e"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga68ea3f4c4c7e0ac2ededda62ba66598e">sd_ant_time_stamp_config_set</a> (<a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a> *pstTimeStampConfig)</td></tr>
<tr class="memdesc:ga68ea3f4c4c7e0ac2ededda62ba66598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time stamp configuration.  <a href="#ga68ea3f4c4c7e0ac2ededda62ba66598e">More...</a><br/></td></tr>
<tr class="separator:ga68ea3f4c4c7e0ac2ededda62ba66598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2056ae3a7830f220f37a369c634b96ff"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga2056ae3a7830f220f37a369c634b96ff">sd_ant_time_stamp_config_get</a> (<a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a> *pstTimeStampConfig)</td></tr>
<tr class="memdesc:ga2056ae3a7830f220f37a369c634b96ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time stamp configuration.  <a href="#ga2056ae3a7830f220f37a369c634b96ff">More...</a><br/></td></tr>
<tr class="separator:ga2056ae3a7830f220f37a369c634b96ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58a0a3801f2247d9f56c857fe58db28"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gae58a0a3801f2247d9f56c857fe58db28">sd_ant_time_sync_config_set</a> (<a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a> *pstTimeSyncConfig)</td></tr>
<tr class="memdesc:gae58a0a3801f2247d9f56c857fe58db28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the time synchronization configuration.  <a href="#gae58a0a3801f2247d9f56c857fe58db28">More...</a><br/></td></tr>
<tr class="separator:gae58a0a3801f2247d9f56c857fe58db28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f8204a4f8c73d118160840a1c229ba"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gac5f8204a4f8c73d118160840a1c229ba">sd_ant_time_sync_config_get</a> (<a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a> *pstTimeSyncConfig)</td></tr>
<tr class="memdesc:gac5f8204a4f8c73d118160840a1c229ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time synchronization configuration.  <a href="#gac5f8204a4f8c73d118160840a1c229ba">More...</a><br/></td></tr>
<tr class="separator:gac5f8204a4f8c73d118160840a1c229ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43093ebe4bc18fa746e35b15992d80b6"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga43093ebe4bc18fa746e35b15992d80b6">sd_ant_time_sync_broadcast_tx</a> (uint8_t ucChannel, uint8_t ucSize, uint8_t *aucMesg)</td></tr>
<tr class="memdesc:ga43093ebe4bc18fa746e35b15992d80b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send a time sync broadcast message.  <a href="#ga43093ebe4bc18fa746e35b15992d80b6">More...</a><br/></td></tr>
<tr class="separator:ga43093ebe4bc18fa746e35b15992d80b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcd0e8ee2c692d64e8e5727be01a557"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga8bcd0e8ee2c692d64e8e5727be01a557">sd_ant_high_duty_search_config_set</a> (const <a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> *pstConfig)</td></tr>
<tr class="memdesc:ga8bcd0e8ee2c692d64e8e5727be01a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the high duty search configuration.  <a href="#ga8bcd0e8ee2c692d64e8e5727be01a557">More...</a><br/></td></tr>
<tr class="separator:ga8bcd0e8ee2c692d64e8e5727be01a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a674f6c3905ef5e43c82a1a44127442"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga3a674f6c3905ef5e43c82a1a44127442">sd_ant_high_duty_search_config_get</a> (<a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> *pstConfig)</td></tr>
<tr class="memdesc:ga3a674f6c3905ef5e43c82a1a44127442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current high duty search configuration.  <a href="#ga3a674f6c3905ef5e43c82a1a44127442">More...</a><br/></td></tr>
<tr class="separator:ga3a674f6c3905ef5e43c82a1a44127442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a0a82750f9cd1595a43f48240033fb"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga32a0a82750f9cd1595a43f48240033fb">sd_ant_config_pa_lna_set</a> (<a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a> *pstAmpConfig)</td></tr>
<tr class="memdesc:ga32a0a82750f9cd1595a43f48240033fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the PA/LNA control configuration.  <a href="#ga32a0a82750f9cd1595a43f48240033fb">More...</a><br/></td></tr>
<tr class="separator:ga32a0a82750f9cd1595a43f48240033fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba814c13a623cf874f4f8749bc51954c"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gaba814c13a623cf874f4f8749bc51954c">sd_ant_config_pa_lna_get</a> (<a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a> *pstAmpConfig)</td></tr>
<tr class="memdesc:gaba814c13a623cf874f4f8749bc51954c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PA/LNA control configuration.  <a href="#gaba814c13a623cf874f4f8749bc51954c">More...</a><br/></td></tr>
<tr class="separator:gaba814c13a623cf874f4f8749bc51954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5526184169b8185fed36486fe0bc4f9a"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga5526184169b8185fed36486fe0bc4f9a">sd_ant_channel_radio_crc_mode_set</a> (uint8_t ucChannel, uint8_t ucCRCMode)</td></tr>
<tr class="memdesc:ga5526184169b8185fed36486fe0bc4f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the CRC mode used by the ANT radio for a specific channel.  <a href="#ga5526184169b8185fed36486fe0bc4f9a">More...</a><br/></td></tr>
<tr class="separator:ga5526184169b8185fed36486fe0bc4f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ad83ae099f50ec08ce0d41d88c3178f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga7ad83ae099f50ec08ce0d41d88c3178f">sd_ant_channel_radio_crc_mode_get</a> (uint8_t ucChannel, uint8_t *ucCRCModeOut)</td></tr>
<tr class="memdesc:ga7ad83ae099f50ec08ce0d41d88c3178f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current CRC mode used by the ANT radio for a specific channel.  <a href="#ga7ad83ae099f50ec08ce0d41d88c3178f">More...</a><br/></td></tr>
<tr class="separator:ga7ad83ae099f50ec08ce0d41d88c3178f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b9352923680fa0271fd87eb3425b044"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga5b9352923680fa0271fd87eb3425b044">sd_ant_search_channel_priority_get</a> (uint8_t ucChannel, uint8_t *pucSearchPriority)</td></tr>
<tr class="memdesc:ga5b9352923680fa0271fd87eb3425b044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the configured search channel priority.  <a href="#ga5b9352923680fa0271fd87eb3425b044">More...</a><br/></td></tr>
<tr class="separator:ga5b9352923680fa0271fd87eb3425b044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e09b22c6ff73fe897d4b2cbcf0d758"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#ga06e09b22c6ff73fe897d4b2cbcf0d758">sd_ant_channel_open</a>(ucChannel)&#160;&#160;&#160;sd_ant_channel_open_with_offset(ucChannel, <a class="el" href="group__ant__parameters.html#ga2020243a3d2e734a0455449d916a7eee">CHANNEL_START_OFFSET_NONE</a>)</td></tr>
<tr class="memdesc:ga06e09b22c6ff73fe897d4b2cbcf0d758"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function opens and activates a channel. The channel to open must be in an assigned state. When opening a master channel, a supplied offset can be provided in order to suggest a minimum channel start time offset (from when the command is issued) to the ANT stack. Specifying CHANNEL_START_OFFSET_NONE will result in default channel start up behaviour. When opening a slave channel, CHANNEL_START_OFFSET_NONE must be used.  <a href="#ga06e09b22c6ff73fe897d4b2cbcf0d758">More...</a><br/></td></tr>
<tr class="separator:ga06e09b22c6ff73fe897d4b2cbcf0d758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71e1a778168fb948cb63e34ed69bafa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ant__interface.html#gab71e1a778168fb948cb63e34ed69bafa">sd_ant_channel_rx_search_timeout_set</a>(ucChannel, ucTimeout)&#160;&#160;&#160;sd_ant_channel_search_timeout_set(ucChannel, ucTimeout)</td></tr>
<tr class="memdesc:gab71e1a778168fb948cb63e34ed69bafa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the channel search timeout. For a slave channel, the configuration applies to rx search timeout. For a master channel, the configuration applies to timeout for starting a transmitter using group transmitter initiation requirements.  <a href="#gab71e1a778168fb948cb63e34ed69bafa">More...</a><br/></td></tr>
<tr class="separator:gab71e1a778168fb948cb63e34ed69bafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ANT Stack Application Programming Interface (API). </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga06e09b22c6ff73fe897d4b2cbcf0d758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sd_ant_channel_open</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ucChannel</td><td>)</td>
          <td>&#160;&#160;&#160;sd_ant_channel_open_with_offset(ucChannel, <a class="el" href="group__ant__parameters.html#ga2020243a3d2e734a0455449d916a7eee">CHANNEL_START_OFFSET_NONE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function opens and activates a channel. The channel to open must be in an assigned state. When opening a master channel, a supplied offset can be provided in order to suggest a minimum channel start time offset (from when the command is issued) to the ANT stack. Specifying CHANNEL_START_OFFSET_NONE will result in default channel start up behaviour. When opening a slave channel, CHANNEL_START_OFFSET_NONE must be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to open. param[in] usOffset is an unsigned short (2 octet) denoting the offset from which to start the channel. See Channel Start Offset in ant_parameters.h</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab71e1a778168fb948cb63e34ed69bafa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sd_ant_channel_rx_search_timeout_set</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ucChannel, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ucTimeout&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;sd_ant_channel_search_timeout_set(ucChannel, ucTimeout)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel search timeout. For a slave channel, the configuration applies to rx search timeout. For a master channel, the configuration applies to timeout for starting a transmitter using group transmitter initiation requirements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTimeout</td><td>is an unsigned char (1 octet) denoting the timeout value. When applied to an assigned slave channel, ucTimeout is in 2.5 second increments. Default = 10 (25s) at channel assignment When applied to an assigned master channel, ucTimeout is in 250ms increments. Default = 0 (disabled) at channel assignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga893d871362f4eaf1e82a6749af27136b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_acknowledge_message_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send an acknowledge message. This message requests an acknowledgement from the slave to validate reception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to send the data on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the message, ucSize must be 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMesg</td><td>is the buffer where the message is located (array must be 8 octets).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gab029e803fd76c402e68652b8a13ea3b9" title="Response if a data message is provided that is too large.">NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT</a> <a class="el" href="group__ant__error.html#gae1813878b3515eda4c731cf8c5bf2f07" title="Response when attempting to transmit on channel 0 when in scan mode.">NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> <a class="el" href="group__ant__error.html#gae324d3154b99f1d6247501e247882841" title="Response when transfer error has occured on supplied burst message or burst data segment.">NRF_ANT_ERROR_TRANSFER_IN_ERROR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a52294fb19c558b644c09af9834995d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbAntActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the ANT activity status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pbAntActive</td><td>is the pointer to an unsigned char (1 octet) where the ANT activity value will be stored. 1 = active, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d681d85ad32f768f4cb0139f4625d34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active_search_sharing_cycles_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the search sharing cycles number of the specified searching channel for active search time sharing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucCycles</td><td>is the pointer to an unsigned char (1 octet) where the cycle value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga533dff69abced3e86d35e026b1b3f2e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_active_search_sharing_cycles_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the search cycle number of separate searching channels for active search time sharing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCycles</td><td>is an unsigned char (1 octet) denoting the number of cycles to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ff68f0ee4408c590755914e40a2ff64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_adv_burst_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the advance burst configuration and supported capabilities. Returned structure is as follows for configuration: Byte0 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h. Byte1 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Byte2 = 0, Reserved Byte3 = 0, Reserved Byte4 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Byte5 = 0, Reserved Byte6 = 0, Reserved Byte7 = Advanced burst stalling count config LSB. Each count represents ~3ms of stalling. Byte8 = Advanced burst stalling count config MSB Byte9 = Advanced burst retry count cycle extension. Each count cycle represents 5 retries. </p>
<pre class="fragment">    Returned structure is as follows for capabilities:
    Byte0 = Supported RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h.
    Byte1 = Supported burst configurations. See Advanced Burst Configuration Defines in ant_parameters.h.
    Byte2 = 0, Reserved
    Byte3 = 0, Reserved
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucRequestType</td><td>is an unsigned char (1 octet) denoting the type of request. 1 = configuration, 0 = capability. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucConfig</td><td>is the pointer to the buffer where the configuration/capabilities will be read to. The array should be at least 10 octets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4919de32f0122fc9ec57e282ee7fece0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_adv_burst_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the advanced burst configuration. Configuration structure is as follows: Required Byte0 = 0-Disable, 1-Enable. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte1 = RF payload size. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte2 = Required advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte3 = 0, Reserved Required Byte4 = 0, Reserved Required Byte5 = Optional advanced burst modes. See Advanced Burst Configuration Defines in ant_parameters.h. Required Byte6 = 0, Reserved Required Byte7 = 0, Reserved Optional Byte8 = Advanced burst stalling count config LSB. Typical is 3210 (~10s of stalling) where each count represents ~3ms of stalling. Optional Byte9 = Advanced burst stalling count config MSB. Optional Byte10 = Advanced burst retry count cycle extension. Typical is 3 (15 retries) where each count cycles represents 5 retries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aucConfig</td><td>is a buffer containing the advanced burst configuration to be set (as stated above). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the configuration parameter buffer. Minimum config set is 8 octets, maximum is 11 octets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga190f13a6952b372514157011766b68ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_auto_freq_hop_table_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function populates the frequency hop table list. This table is used when frequency hopping is enabled on a channel via extended assignment bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set the frequency hop table list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq0</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 1st frequency hop value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq1</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 2nd frequency hop value. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq2</td><td>is an unsigned char (1 octet) denoting the offset from 2400MHz of the 3rd frequency hop value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e48883c0e50c1c380b61fd0c28b3879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_broadcast_message_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to set broadcast data for transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to send the data on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the message, ucSize must be 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMesg</td><td>is the buffer where the message is located (array must be 8 octets).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gab029e803fd76c402e68652b8a13ea3b9" title="Response if a data message is provided that is too large.">NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT</a> <a class="el" href="group__ant__error.html#gae1813878b3515eda4c731cf8c5bf2f07" title="Response when attempting to transmit on channel 0 when in scan mode.">NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> <a class="el" href="group__ant__error.html#gae324d3154b99f1d6247501e247882841" title="Response when transfer error has occured on supplied burst message or burst data segment.">NRF_ANT_ERROR_TRANSFER_IN_ERROR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa09761cfc5e7373048e90e2dca208e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_request </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucBurstSegment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to queue data for burst transmission. After every successful call, the input buffer is held in use by the burst handler and must not be changed. When the burst handler releases the input buffer, it will either generate a <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> event or clear a specified wait flag assigned to the burst handler. Transfer end events: <a class="el" href="group__ant__parameters.html#ga51573152c1529ee27fed45e93372728f">EVENT_TRANSFER_TX_COMPLETED</a> and <a class="el" href="group__ant__parameters.html#gaf9f5a3fd4304ebae7e61e6ce78fed2b9">EVENT_TRANSFER_TX_FAILED</a> also releases the input buffer. Special care must be made to ensure that the input buffer does not change until it is released by the burst handler to avoid data corruption. Use of burst segment identifiers (<a class="el" href="group__ant__parameters.html#ga37b944eb5dc2a7468e5a347bbb91e836">BURST_SEGMENT_START</a>, <a class="el" href="group__ant__parameters.html#ga56e39155014fde638f41df68325db77f">BURST_SEGMENT_CONTINUE</a>, and <a class="el" href="group__ant__parameters.html#ga113c56011fdb29743c5b46bd938098f0">BURST_SEGMENT_END</a>) is required to indicate the sequence of the data block being sent as a burst transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to do a burst transmission. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usSize</td><td>is an unsigned short (2 octets) denoting the size of the message block. Size must be divisible by 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucData</td><td>is the buffer where the message block is located. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucBurstSegment</td><td>is an unsigned char (1 octet) containing a bitfield representing the message block type. See Tx Burst Handler Request Segment Defines in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gae1813878b3515eda4c731cf8c5bf2f07" title="Response when attempting to transmit on channel 0 when in scan mode.">NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL</a> <a class="el" href="group__ant__error.html#ga709a9d777285a2bbdade6b4d570ceb7f" title="Response on attempt to communicate on a channel that is not open.">NRF_ANT_ERROR_CHANNEL_NOT_OPENED</a> <a class="el" href="group__ant__error.html#ga95a1031bc77561ab4199f6f634e51d2e" title="Response when sequence number of burst message or burst data segment is out of order.">NRF_ANT_ERROR_TRANSFER_SEQUENCE_NUMBER_ERROR</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> <a class="el" href="group__ant__error.html#gae324d3154b99f1d6247501e247882841" title="Response when transfer error has occured on supplied burst message or burst data segment.">NRF_ANT_ERROR_TRANSFER_IN_ERROR</a> <a class="el" href="group__ant__error.html#gab029e803fd76c402e68652b8a13ea3b9" title="Response if a data message is provided that is too large.">NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__ant__error.html#ga808b01467335e6e845fae4e483fff632" title="Response when transfer is busy and cannot process supplied burst message or burst data segment...">NRF_ANT_ERROR_TRANSFER_BUSY</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab4cc4eb62a0b01c7bdc2b235e4417184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_wait_flag_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unassigns any previously assigned wait variable from the burst handler. The burst handler returns to the default method in generating <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> to indicate input buffer unlock. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9555406ba64e0005d0ae57e346910026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_burst_handler_wait_flag_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucWaitFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a wait variable to the the burst handler. When the input buffer is locked by the handler the wait flag is set to 1. When the input buffer is unlocked, the wait flag is set to 0. When a wait flag is assigned, <a class="el" href="group__ant__parameters.html#ga79ea77f1981aed66f580b396d5b86f05">EVENT_TRANSFER_NEXT_DATA_BLOCK</a> events will not be generated until the wait flag unassigned. The wait flag should be declared as a static variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucWaitFlag</td><td>is the pointer to a static unsigned char (1 octet) where the status of the burst handler will be updated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6ae3c048f41006e2beb531a5e875385d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_capabilities_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucCapabilities</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the capabilities of the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aucCapabilities</td><td>is the pointer to the buffer where the capabilities message will be copied, the array should be at least 9 octets. Byte0 = Maximum supported ANT channels Byte1 = Maximum supported ANT networks Byte2 = CAPABILITIES_STANDARD. See Standard capabilities defines in ant_parameters.h Byte3 = CAPABILITIES_ADVANCED. See Advanced capabilities defines in ant_parameters.h Byte4 = CAPABILITIES_ADVANCED_2. See Advanced capabilities 2 defines in ant_parameters.h Byte5 = Maximum support ANT data channels (only applicable for SensRcore support) Byte6 = CAPABILITIES_ADVANCED_3. See Advanced capabilities 3 defines in ant_parameters.h Byte7 = CAPABILITIES_ADVANCED_4. Advanced capabilities 4 defines in ant_parameters.h Byte8 = CAPABILITIES_ADVANCED_5. Advanced capabilities 5 defines in ant_parameters.h</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ee008ec03098a855dd200c9cec28854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannelType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucExtAssign</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns and initializes a new channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to assign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannelType</td><td>is an unsigned char (1 octet) denoting the channel type. See Assign Channel Parameters/Assign Channel Types in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucNetwork</td><td>is an unsigned char (1 octet) denoting the network key to associate with the channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtAssign</td><td>is a bit field (1 octet) for an extended assign. See Ext. Assign Channel Parameters in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#ga780c667bc071f477db392dc07a2e444d" title="Response when an invalid network number is provided.">NRF_ANT_ERROR_INVALID_NETWORK_NUMBER</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad6b069b1d3147d0bcac9505efa60dea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function closes a channel. The channel must be in an open state (SEARCHING or TRACKING). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafcb9a891d63281d8e018ea923d6e6dc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_id_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusDeviceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucDeviceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucTransmitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current Channel ID of a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusDeviceNumber</td><td>is the pointer to an unsigned short (2 octets) where the device number will be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucDeviceType</td><td>is the pointer to an unsigned char (1 octet) where the device type will be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucTransmitType</td><td>is the pointer to an unsigned char (1 octet) where the transmit type will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac19f4abd3e4d46b4b2f8f0397aa9c113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_id_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usDeviceNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucDeviceType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTransmitType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usDeviceNumber</td><td>is an unsigned short (2 octets) denoting the device number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucDeviceType</td><td>is an unsigned char (1 octet) denoting the device type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTransmitType</td><td>is an unsigned char (1 octet) denoting the transmission type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab50ecb72e0edd83d1e8e11e50f17a210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_in_progress </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pbChannelInProgress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the status if the channel is in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pbChannelInProgress</td><td>is the pointer to an unsigned char (1 octet) where the result will be stored. 1 = in progress, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafc75068807b29d6cd80266309536b605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_low_priority_rx_search_timeout_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the low priority search timeout value of a channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTimeout</td><td>is an unsigned char (1 octet) denoting the timeout value in 2.5 seconds increments. Default = 2 (5s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad101863c3a594c0a05d6bdb20dc82d0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_period_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the current channel period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusPeriod</td><td>is the pointer to an unsigned short (2 octets) where the channel period will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5f02ffc719c4589cc7943d6fb67f34e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_period_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set the period to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usPeriod</td><td>is an unsigned short (2 octets) denoting the period in 32 kHz counts (usPeriod/32768 s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7ad83ae099f50ec08ce0d41d88c3178f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_channel_radio_crc_mode_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ucCRCModeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current CRC mode used by the ANT radio for a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to get the CRC mode for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ucCRCModeOut</td><td>is a pointer to unsigned char (1 octet) that will be set to the current <a class="el" href="group___c_r_c___m_o_d_e.html">CRC mode</a> used by the channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5526184169b8185fed36486fe0bc4f9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_channel_radio_crc_mode_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCRCMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the CRC mode used by the ANT radio for a specific channel. </p>
<p>CAUTION: Changing this will break compatability with existing ant radio devices. Channels using an alternate CRC mode will only be able to communicate with other channels using the same CRC mode, and should generally be used with frequency/network-key combinations that are not widely used by other ANT devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to change the CRC mode on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCRCMode</td><td>is an unsigned char (1 octet) denoting the <a class="el" href="group___c_r_c___m_o_d_e.html">CRC mode</a> to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga874e9c551db1f3297a0253c5142106bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_freq_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucRfreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the radio frequency of an ANT channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucRfreq</td><td>is the pointer to an unsigned char (1 octet) where the frequency will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga28b87b0df8a35fe5e8ffb23e7bd89967"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_freq_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the radio frequency of an ANT channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucFreq</td><td>is an unsigned char (1 octet) denoting the radio frequency offset from 2400MHz (eg. 2466MHz, ucFreq = 66). Frequency bands are capped to the Bluetooth ISM band. Min:2402 Max:2480.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga70e472a2603eb90c0a6a8af71e764135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_radio_tx_power_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTxPower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomTxPower</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the radio tx power. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to assign the radio tx power. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTxPower</td><td>is an unsigned char (1 octet) denoting the ANT transmit power index. See Radio TX Power Definitions in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomTxPower</td><td>is an unsigned char (1 octet) denoting the custom nRF transmit power as defined in nrf51_bitfields.h. Only applicable if ucTxPower is set to custom tx power selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaddc5a64712fcf2117071a5136cc976f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_status_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets a specific channel's status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucStatus</td><td>is the pointer to an unsigned char (1 octet) where the channel status will be stored. See Channel Status in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafe35f6cb447e86746361f1411953c171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_channel_unassign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function unassigns a channel. The channel to unassign must be in an assigned state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to unassign.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa7782d6fcedf0de409c004ce88f1b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_coex_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *&#160;</td>
          <td class="paramname"><em>pstCoexConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *&#160;</td>
          <td class="paramname"><em>pstAdvCoexConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the configured ANT radio coexistence behaviour as described in ant_coex_config_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pstCoexConfig</td><td>is the pointer to a buffer where the coexistence configuration will be stored. Set as null to ignore. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pstAdvCoexConfig</td><td>is the pointer to a buffer where the advanced coexistence configuration will be stored. Set as null to ignore.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e4a252715e30105ba3f2f72165b5630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_coex_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *&#160;</td>
          <td class="paramname"><em>pstCoexConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___b_u_f_f_e_r___p_t_r.html">ANT_BUFFER_PTR</a> *&#160;</td>
          <td class="paramname"><em>pstAdvCoexConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets ANT radio coexistence behaviour. Supported only if ANT is sharing radio HW concurrently with another wireless protocol. Configuration structure is as follows: Byte0 = Configuration enable bitfield bit0 - enable/disable tx/rx channel keep alive config (Byte4/5 &amp; Byte6/7) bit1 - enable/disable tx/rx channel fixed interval priority config (Byte1) bit2 - enable/disable transfer keep alive config (Byte2) bit3 - enable/disable search channel fixed interval priority config (Byte3) else - reserved Byte1 = tx/rx channel fixed interval priority configuration Byte2 = transfer keep alive configuration Byte3 = search channel fixed interval priority configuration Byte4(LSB)/Byte5(MSB) = tx channel keep alive configuration Byte6(LSB)/Byte7(MSB) = rx channel keep alive configuration Byte8 = ANT counts/16 spent in high priority mode during search scan. Byte9 = ANT counts/16 spent in low priority mode during search scan. </p>
<pre class="fragment">     Advanced configuration structure is as follows:
     Byte0 = Configuration enable bitfield
             bit0 - enable/disable priority override config (Byte1)
             bit1-7 - reserved
     Byte1 = ANT priority override. 0 = low, 1 = normal(default), 2 = high, 3 = critical
     Byte2 = Reserved
     Byte3 = Reserved
     Byte4 = Reserved
     Byte5 = Reserved
     Byte6 = Reserved
     Byte7 = Reserved
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel for which the coexistence configuration is to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstCoexConfig</td><td>is a buffer containing the coex configuration to be set. Set as null for no change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pstAdvCoexConfig</td><td>is a buffer containing the advanced coex configuration to be set. Set as null for no change.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba814c13a623cf874f4f8749bc51954c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_config_pa_lna_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstAmpConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the PA/LNA control configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstAmpConfig</td><td>Pointer to the configuration for PA/LNA control <a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga32a0a82750f9cd1595a43f48240033fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_config_pa_lna_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstAmpConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the PA/LNA control configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstAmpConfig</td><td>Pointer to the configuration for PA/LNA control <a class="el" href="struct_a_n_t___p_a___l_n_a___c_o_n_f_i_g.html">ANT_PA_LNA_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__nrf__error.html#gaf0aff2ba7864b34a36b4a96986e1851e" title="Invalid state, operation disallowed in this state.">NRF_ERROR_INVALID_STATE</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d633f9ec84b9a81063dbb29ad675ed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_channel_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucKeyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucDecimationRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables 128-bit AES encryption mode to the specified channel. Advanced burst must be enabled beforehand to enable encrypted channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel in which encryption mode is set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEnable</td><td>is an unsigned char (1 octet) denoting the encryption mode. See Encrypted Channel Defines in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucKeyNum</td><td>is an unsigned char (1 octet) denoting the key index of the 128-bit key to be used for encryption. The key index range is bound by the number of encrypted channels configured by <a class="el" href="group__ant__interface.html#gac890b37f9e3e5f7ef08add20117dd3ad" title="This function is used to specify the total number of ANT channels, number of encrypted channels (subs...">sd_ant_enable()</a>. If <a class="el" href="group__ant__interface.html#gac890b37f9e3e5f7ef08add20117dd3ad" title="This function is used to specify the total number of ANT channels, number of encrypted channels (subs...">sd_ant_enable()</a> is not used then by default ucKeyNum is 0. Range is [0 to (num encrypted channels - 1)], if 1 or more encrypted channels are configured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucDecimationRate</td><td>is an unsigned char (1 octet) denoting the decimate rate to apply for encrypted slave channel. Must be &gt; 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gae1813878b3515eda4c731cf8c5bf2f07" title="Response when attempting to transmit on channel 0 when in scan mode.">NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL</a> <a class="el" href="group__ant__error.html#ga709a9d777285a2bbdade6b4d570ceb7f" title="Response on attempt to communicate on a channel that is not open.">NRF_ANT_ERROR_CHANNEL_NOT_OPENED</a> <a class="el" href="group__ant__error.html#ga95a1031bc77561ab4199f6f634e51d2e" title="Response when sequence number of burst message or burst data segment is out of order.">NRF_ANT_ERROR_TRANSFER_SEQUENCE_NUMBER_ERROR</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> <a class="el" href="group__ant__error.html#gae324d3154b99f1d6247501e247882841" title="Response when transfer error has occured on supplied burst message or burst data segment.">NRF_ANT_ERROR_TRANSFER_IN_ERROR</a> <a class="el" href="group__ant__error.html#gab029e803fd76c402e68652b8a13ea3b9" title="Response if a data message is provided that is too large.">NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__ant__error.html#ga808b01467335e6e845fae4e483fff632" title="Response when transfer is busy and cannot process supplied burst message or burst data segment...">NRF_ANT_ERROR_TRANSFER_BUSY</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga84f62c111be73ea126866e9d097a1480"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucType</td><td>is an unsigned char (1 octet) denoting the type of information being requested. See Encrypted Channel Defines in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucInfo</td><td>is a pointer to a buffer in which the information retrieved will be copied to (1 octet for supported mode, 4 octets for ID, 19 octets for custom user data).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga04b1c52c190dd267646f9968488c6c3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_info_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets specific information to be exchanged between the channel master and slave during encryption channel set-up/negotiation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucType</td><td>is an unsigned char (1 octet) denoting the type of information being set. See Encrypted Channel Defines in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucInfo</td><td>is a buffer containing the information being set (4 octets for ID, 19 octets for custom user data).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabaf590fd95860473bdd4a99f91443453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_crypto_key_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucKeyNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a 128-bit AES encryption key to a key index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucKeyNum</td><td>is an unsigned char (1 octet) denoting the key index for assignment. The key index range is bound by the number of encrypted channels configured by <a class="el" href="group__ant__interface.html#gac890b37f9e3e5f7ef08add20117dd3ad" title="This function is used to specify the total number of ANT channels, number of encrypted channels (subs...">sd_ant_enable()</a>. If <a class="el" href="group__ant__interface.html#gac890b37f9e3e5f7ef08add20117dd3ad" title="This function is used to specify the total number of ANT channels, number of encrypted channels (subs...">sd_ant_enable()</a> is not used then by default ucKeyNum is 0. Range is [0 to (num encrypted channels - 1)], if 1 or more encrypted channels are configured. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucKey</td><td>is a buffer (16 octets) containing the 128-bit AES key to be assigned to the key index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac67e3eba7d08bcf6250db7388ca36641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_cw_test_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucRadioFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucTxPower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomTxPower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts a continuous wave test mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucRadioFreq</td><td>is an unsigned char (1 octet) denoting the radio frequency offset from 2400MHz for continuous wave mode. (eg. 2466MHz, ucRadioFreq = 66). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucTxPower</td><td>is an unsigned char (1 octet) denoting the ANT transmit power index for continuous wave mode. See Radio TX Power Definitions in ant_parameters.h </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomTxPower</td><td>is an unsigned char (1 octet) denoting the custom nRF transmit power as defined in nrf51_bitfields.h. Only applicable if ucTxPower is set to custom tx power selection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMode</td><td>is an unsigned char (1 octet) denoting test mode type where 0 = cw tx carrier transmission, 1 = cw tx modulated transmission</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0bb311b7dfbb4457119e5144de9008a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_cw_test_mode_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initialize the stack to get ready for a continuous wave transmission test. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac890b37f9e3e5f7ef08add20117dd3ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___e_n_a_b_l_e.html">ANT_ENABLE</a> *const&#160;</td>
          <td class="paramname"><em>pstChannelEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to specify the total number of ANT channels, number of encrypted channels (subset of total ANT channels) and transmit burst queue size to be supported by the ANT stack. Upon enabling the SoftDevice successfully, the ANT stack defaults to supporting 1 ANT channel (encryption capable) and a 64 byte transmit burst buffer. If additional channels are needed and/or more encrypted channels are needed and/or larger tx burst buffer size is needed, then the desired configuration can be specified to the SoftDevice using this function. In this case, a static RAM buffer (of minimum size defined by <a class="el" href="group__ant__parameters.html#gaf53cab067ff8c0fed43823a1ceebd701">ANT_ENABLE_GET_REQUIRED_SPACE</a>) must be supplied by the application to be used by the ANT SoftDevice stack. </p>
<pre class="fragment">     Notes: - If used, function should be called immediately after sd_softdevice_enable() and before any ANT related SVC calls.
            - Using sd_ant_stack_reset() will not reset ANT stack channel allocation configuration. It will be maintained.
            - Disabling the SoftDevice and then re-enabling the SoFtDevice will reset channel allocation to default. Any previously supplied memory buffer by the application will not be used.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstChannelEnable</td><td>is a pointer to <a class="el" href="struct_a_n_t___e_n_a_b_l_e.html">ANT_ENABLE</a> structure. where ucTotalNumberOfChannels is an unsigned char (1 octet) denoting the total number of ANT channels desired (1 to <a class="el" href="group__ant__parameters.html#ga9af7557143323ed81fd2dc050a16049a">MAX_ANT_CHANNELS</a>, defined in ant_parameters.h) where ucTotalNumberOfEncryptedChannels is an unsigned char (1 octet) denoting the total number of ANT channels (0 to ucTotalNumberOfChannels) that support encryption where pucMemoryBlockStartLocation is the pointer to an application supplied buffer to be used by the ANT SoftDevice stack. where usMemoryBlockByteSize is an unsigned short (2 octet) denoting the size of the given memory block (pucMemoryBlockStartLocation). The defined <a class="el" href="group__ant__parameters.html#gaf53cab067ff8c0fed43823a1ceebd701">ANT_ENABLE_GET_REQUIRED_SPACE</a> macro (see ant_parameters.h) should be used to determine the minimum buffer size requirement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga64f53a10a2c7c7e4b2a392a09e7576f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_enhanced_channel_spacing_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucEnable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function enables or disables the enhanced channel spacing feature. This feature is enabled by default and is used to reduce internal channel collisions when running multiple tracking channels with channel periods that are synchronous with each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucEnable</td><td>is a unsigned char (1 octet) denoting enable/disable control. See Enhanced Channel Spacing Defines in ant_parameters.h</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9297eb25b36a2cc0c6a221a3df9bd4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_filtering_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to retrieve the filter configuration for channel event message generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pusFilter</td><td>is the pointer to an unsigned short (2 octets) where the filter configuration will be stored. See Event Filtering in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7cbb544dccb5be899079effe993db66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_filtering_set </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to specify filter configuration for channel event message generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">usFilter</td><td>is an unsigned short (2 octets) denoting the filter configuration bitfield. See Event Filtering in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga871ce84112f0aa7dc40468a7d6b3fdbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_event_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucANTMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns ANT channel events and data messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pucChannel</td><td>is the pointer to an unsigned char (1 octet) where the channel number will be copied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucEvent</td><td>is the pointer to an unsigned char (1 octet) where the event code will be copied. See Channel Events and Command Response Codes in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucANTMesg</td><td>is the buffer where event's message will be copied. The array size must be at least <a class="el" href="group__ant__parameters.html#gac05f0827e5d0372c4b50727da960dae1">MESG_BUFFER_SIZE</a> to accommadate the entire <a class="el" href="union_a_n_t___m_e_s_s_a_g_e.html">ANT_MESSAGE</a> structure size. See ANT Message Structure in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd>
<dd>
<a class="el" href="group__nrf__error.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae19a46dbb68569e329be746299bdd96a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_extended0 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ucExtID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvArg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extended0 ANT SVCs. Access extended SVC functions via ucExtID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucExtID</td><td>is the extended ID defined by SD_ANT_EXT0_ID_&lt;name&gt; </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg0</td><td>is first argument to extended ANT SVC function specified by ucExtID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg1</td><td>is second argument to extended ANT SVC function specified by ucExtID </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pvArg2</td><td>is third argument to extended ANT SVC function specified by ucExtID</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value(s) of extended ANT SVC function specified by ucExtID </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a674f6c3905ef5e43c82a1a44127442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_high_duty_search_config_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current high duty search configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pstConfig</td><td>is a pointer to an <a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> struct whose fields will be set to the current configuration values of the stack.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> if pstConfig points to invalid memory. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bcd0e8ee2c692d64e8e5727be01a557"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_high_duty_search_config_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the high duty search configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstConfig</td><td>is a pointer to an <a class="el" href="struct_a_n_t___h_i_g_h___d_u_t_y___s_e_a_r_c_h___c_o_n_f_i_g.html">ANT_HIGH_DUTY_SEARCH_CONFIG</a> struct containing the configuration to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> if pstConfig points to invalid memory. <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> if any ANT channels are open while changing the config. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc8dd07669424ef4e30dfaa75fa00a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_id_list_add </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucDevId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucListIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to add a Device ID to an include or exclude list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to add the list entry to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucDevId</td><td>is the pointer to the buffer (4 octets) containing device ID information with the following format: Byte0 = DeviceNumber_LSB Byte1 = DeviceNumber_MSB Byte2 = DeviceType Byte3 = TransType </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucListIndex</td><td>is an unsigned char (1 octet) denoting the index where the specified Channel ID is to be placed in the list (0-3).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gaf3759c68825f7b06613f82bccb411e60" title="Response when the provided list ID or size exceeds the limit.">NRF_ANT_ERROR_INVALID_LIST_ID</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeaf8ece10c4b90f397fac9f760408c64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_id_list_config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucIDListSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucIncExcFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to configure the device ID list as include or exclude as well as the number of IDs to compare against. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number of the device ID list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucIDListSize</td><td>is an unsigned char (1 octet) denoting the size of the inclusion or exclusion list (0-4). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucIncExcFlag</td><td>is an unsigned char (1 octet) denoting the type of list as Include(0) or Exclude(1)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gaf3759c68825f7b06613f82bccb411e60" title="Response when the provided list ID or size exceeds the limit.">NRF_ANT_ERROR_INVALID_LIST_ID</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga67109fc1c0cb71cb88976d554ae3cd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_clear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears the ANT Messaging Library Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucANTLibConfig</td><td>is an unsigned char (1 octet) denoting the ANT lib Config bit(s) to clear. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5044f2aea53e57eb113fc8f4afd02b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns current ANT Messaging Library Configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pucANTLibConfig</td><td>is the pointer to an unsigned char (1 octet) where the bit flags will be stored. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf75d7ef14fd9efe9fbad3f1892fd5c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_lib_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucANTLibConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the ANT Messaging Library Configuration used by Extended messaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucANTLibConfig</td><td>is an unsigned char (1 octet) denoting the ANT lib config bit flags. See ANT Library Config in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a05168143a2c54efb138eeaf74a6e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_network_address_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucNetwork</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>aucNetworkKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the 64bit network address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucNetwork</td><td>is an unsigned char (1 octet) denoting the network number to assign the network address to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucNetworkKey</td><td>is the pointer to location of the Network Key (8 octets in length)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#ga780c667bc071f477db392dc07a2e444d" title="Response when an invalid network number is provided.">NRF_ANT_ERROR_INVALID_NETWORK_NUMBER</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c0e2144ea9c33340c3ee660eef0ebec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_pending_transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucPending</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function determines if there is a pending transmission on a specific channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucPending</td><td>is the pointer to an unsigned char (1 octet) where the pending result will be stored. 1 = pending, 0 = otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga93a4111cc6e4b75e3b6b4d665937e625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_pending_transmit_clear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucSuccess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function clears a pending transmit. Primarily intended for shared slave channels (receive channel). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to clear pending transmit. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucSuccess</td><td>is the pointer to an unsigned char (1 octet) where the result will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga06b245376f5a6a1b1cc3eb747b12a245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_prox_search_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucProxThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucCustomProxThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensitivity threshold for acquisition on a searching channel. One time set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucProxThreshold</td><td>is an unsigned char (1 octet) denoting the minimum RSSI threshold required for acquisition during a search. See Radio Proximity Search Threshold in ant_parameters.h </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucCustomProxThreshold</td><td>is an unsigned char (1 octet) denoting the custom minimum RSSI threshold for acquisition during a search. Only applicable if ucProxThreshold is set to custom proximity selection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa66114d4387791c8b4b20317698d6cb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rfactive_notification_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>pusTimeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function retrieves the ANT rf active notification configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pucMode</td><td>is a pointer to an unsigned char (1 octet) where the configured mode of event notification will be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pusTimeThreshold</td><td>is a pointer to an unsigned short (2 octets) where the configured time threhold value will be stored. Time threshold is in 32 kHz counts (usTimeThreshold/32768 s).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga74d5df5b5e66bf6d40b283e80842c0c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rfactive_notification_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usTimeThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function enables/disables event notifications to be generated to the application indicating the time to the next ANT radio activity exceeds the configured time threshold. Latency (delay in event notification being received and processed by application) must be taken into account if attempting to use this generated event to perform operations prior to the radio activity. Cannot be used if asynchronous tx channel is assigned or used. Please note that this only generates events for ANT radio activity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMode</td><td>is an unsigned char (1 octet) denoting the mode of event notification. See RFActive Notification Defines in ant_parameters.h. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usTimeThreshold</td><td>is an unsigned short (2 octets) denoting the minimum time threshold (32 kHz counts (usTimeThreshold/32768 s)) before the next radio activity that will trigger generation of the event notification.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaafafa38f71054778becea049bc3ada46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_rx_scan_mode_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSyncChannelPacketsOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function starts receive scanning mode feature. Channel 0 must be assigned. All other channels must be closed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSyncChannelPacketsOnly</td><td>is an unsigned char (1 octet) denoting synchronous channel only scanning mode. 0 = disable, 1 = enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#ga9a743d59e33a719f366bc0c277e44b17" title="Response when attempting to start scanning mode, when channels are still open.">NRF_ANT_ERROR_CLOSE_ALL_CHANNELS</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga23878b31b61d3314ed4a315a55afca90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMaskConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assigns a SDU mask configuration to a particular channel. The configuration specifies the mask identifier and the type of rx data in which the mask should be applied to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel in which the SDU mask configuration is to be applied to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMaskConfig</td><td>is an unsigned char (1 octet) denoting SDU mask configuration. See Selective Data Update Mask Configuration Defines in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b975a9f6539705f63863d11d8ca4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns the selective data update (SDU) mask (8 octets) from the specified identifier, ucMask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMask</td><td>is an unsigned char (1 octet) denoting the index representing the SDU data mask. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">aucMask</td><td>is a pointer to the buffer where the SDU data mask will be copied, the array should be at least 8 octects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga231d8b588e95f769b07b6fbdd879d439"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_sdu_mask_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to assign a selective data update (SDU) mask (8 octets) to an identifier, ucMask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucMask</td><td>is an unsigned char (1 octet) denoting the index representing the SDU data mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMask</td><td>is a buffer (8 octets) containing the SDU mask to be assigned to ucMask.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b9352923680fa0271fd87eb3425b044"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_search_channel_priority_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pucSearchPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the configured search channel priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet denoting the channel) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pucSearchPriority</td><td>is a pointer to an unsigned char (1 octet) denoting the configured search channel priority</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3020bbb168a16049a94e39f3742a96e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_search_channel_priority_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSearchPriority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the channel's search priority. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSearchPriority</td><td>is an unsigned char (1 octet) denoting the search priority value. 0 to 7 (Default = 0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4de80c986c5f0be170c850ea50a639a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_search_waveform_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>usWaveform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the searching waveform value of an ANT Channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel number to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">usWaveform</td><td>is an unsigned short (2 octets) denoting the channel waveform period (usWaveform/32768 s). Default = 316.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga38b44d71b463cfd0d12fa07b63191d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_stack_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for resetting the ANT Stack. This is a blocking operation. If the operation has timed out (after ~2 seconds), then NRF_ERROR_TIMEOUT is returned and the application must try again. Otherwise, upon successful reset, NRF_SUCCESS is returned. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd>
<dd>
<a class="el" href="group__nrf__error.html#gaf3ac440fa84dedc1a80baab36da36f80" title="Operation timed out.">NRF_ERROR_TIMEOUT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2056ae3a7830f220f37a369c634b96ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_time_stamp_config_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstTimeStampConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the time stamp configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pstTimeStampConfig</td><td>Pointer to the configuration for the time stamp <a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga68ea3f4c4c7e0ac2ededda62ba66598e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_time_stamp_config_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstTimeStampConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the time stamp configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstTimeStampConfig</td><td>Pointer to the configuration for the time stamp <a class="el" href="struct_a_n_t___t_i_m_e___s_t_a_m_p___c_o_n_f_i_g.html">ANT_TIME_STAMP_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43093ebe4bc18fa746e35b15992d80b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_time_sync_broadcast_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucMesg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function is used to send a time sync broadcast message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucChannel</td><td>is an unsigned char (1 octet) denoting the channel to send the data on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ucSize</td><td>is an unsigned char (1 octet) denoting the size of the message, ucSize must be 8. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aucMesg</td><td>is the buffer where the message is located (array must be 8 octets).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> <a class="el" href="group__ant__error.html#gad81d92c712fff6617de08803133e3ee8" title="Response when an invalid parameter is specified in a configuration message.">NRF_ANT_ERROR_INVALID_PARAMETER_PROVIDED</a> <a class="el" href="group__ant__error.html#gab029e803fd76c402e68652b8a13ea3b9" title="Response if a data message is provided that is too large.">NRF_ANT_ERROR_MESSAGE_SIZE_EXCEEDS_LIMIT</a> <a class="el" href="group__ant__error.html#gae1813878b3515eda4c731cf8c5bf2f07" title="Response when attempting to transmit on channel 0 when in scan mode.">NRF_ANT_ERROR_INVALID_SCAN_TX_CHANNEL</a> <a class="el" href="group__ant__error.html#ga5b0ab7ccef5e3ceba284982ec2ed09e7" title="Response on attempt to perform an action from the wrong channel state.">NRF_ANT_ERROR_CHANNEL_IN_WRONG_STATE</a> <a class="el" href="group__ant__error.html#ga460c07f11f1a95c756479dda71736195" title="Response on attempt to communicate on a channel with a TX transfer in progress.">NRF_ANT_ERROR_TRANSFER_IN_PROGRESS</a> <a class="el" href="group__ant__error.html#gae324d3154b99f1d6247501e247882841" title="Response when transfer error has occured on supplied burst message or burst data segment.">NRF_ANT_ERROR_TRANSFER_IN_ERROR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac5f8204a4f8c73d118160840a1c229ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_time_sync_config_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstTimeSyncConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the time synchronization configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstTimeSyncConfig</td><td>Pointer to the configuration for the timeSync <a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae58a0a3801f2247d9f56c857fe58db28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_time_sync_config_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a> *&#160;</td>
          <td class="paramname"><em>pstTimeSyncConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the time synchronization configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pstTimeSyncConfig</td><td>Pointer to the configuration for the timeSync <a class="el" href="struct_a_n_t___t_i_m_e___s_y_n_c___c_o_n_f_i_g.html">ANT_TIME_SYNC_CONFIG</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga59fb0d7717ce7e81a0adecd247511b17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_transfer_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function kills a receive transfer that is in progress. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga529f053ac81ed70c97ade5a8ee7ddb4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ant_version_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>aucVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the version string of the ANT stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">aucVersion</td><td>is the pointer to the buffer where the version string will be copied, the array should be at least MESG_VERSION_STRING (see ant_parameters.h) number of octets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa08965193dd425a1bbee4d8209766da6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_wakeon_rf_activity_config_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ucWakeupConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function retrieves the configured CPU wake on ANT RF activity behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ucWakeupConfig</td><td>is a pointer to an unsigned char (1 octet) where the CPU wakeup configuration will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5a8ed9bce422370f99b312a7c6e6580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t sd_ant_wakeon_rf_activity_config_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>ucWakeupConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function configures CPU wake on ANT RF activity behaviour. CPU is woken up via generation of SD_EVENT_IRQn interrupt upon the start of specified RF activity. In order to wakeup in the event that SD_EVENT_IRQn is disabled, the SEVONPEND flag has to be set in the Cortex-M0 System Control Register (SCR). CPU is dissallowed from entering low power state when calling sd_app_event_wait() for the duration of the RF activity. The intention of this function is to allow/disallow sudden shifts in current consumption during RF transmission/ RF reception window which may impact RF performance. When enabled there is a slight increase in average current consumption for ANT activities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ucWakeupConfig</td><td>is an unsigned char (1 octet) denoting the CPU wakeup configuration. See Wake On RF Activity Defines in ant_parameters.h.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a> <a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

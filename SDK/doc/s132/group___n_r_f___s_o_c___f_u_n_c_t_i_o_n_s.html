<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>S132 SoftDevice v7.2.0: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">S132 SoftDevice
   &#160;<span id="projectnumber">v7.2.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__nrf__soc__api.html">SoC Library API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d">sd_mutex_new</a> (<a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a mutex.  <a href="#ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d">More...</a><br/></td></tr>
<tr class="separator:ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaa1407f50bb45705fea4b2bfee5ff01d7">sd_mutex_acquire</a> (<a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to acquire a mutex.  <a href="#gaa1407f50bb45705fea4b2bfee5ff01d7">More...</a><br/></td></tr>
<tr class="separator:gaa1407f50bb45705fea4b2bfee5ff01d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccdf301739ba049b9ec635832120573"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaaccdf301739ba049b9ec635832120573">sd_mutex_release</a> (<a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *p_mutex)</td></tr>
<tr class="memdesc:gaaccdf301739ba049b9ec635832120573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a mutex.  <a href="#gaaccdf301739ba049b9ec635832120573">More...</a><br/></td></tr>
<tr class="separator:gaaccdf301739ba049b9ec635832120573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e372c86c718f517174c53a611792489"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga7e372c86c718f517174c53a611792489">sd_rand_application_pool_capacity_get</a> (uint8_t *p_pool_capacity)</td></tr>
<tr class="memdesc:ga7e372c86c718f517174c53a611792489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the capacity of the application random pool.  <a href="#ga7e372c86c718f517174c53a611792489">More...</a><br/></td></tr>
<tr class="separator:ga7e372c86c718f517174c53a611792489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad12d1ebe6550185897326166e3d4591"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaad12d1ebe6550185897326166e3d4591">sd_rand_application_bytes_available_get</a> (uint8_t *p_bytes_available)</td></tr>
<tr class="memdesc:gaad12d1ebe6550185897326166e3d4591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of random bytes available to the application.  <a href="#gaad12d1ebe6550185897326166e3d4591">More...</a><br/></td></tr>
<tr class="separator:gaad12d1ebe6550185897326166e3d4591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga825412a3746ef587c60d221240691dcd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga825412a3746ef587c60d221240691dcd">sd_rand_application_vector_get</a> (uint8_t *p_buff, uint8_t length)</td></tr>
<tr class="memdesc:ga825412a3746ef587c60d221240691dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get random bytes from the application pool.  <a href="#ga825412a3746ef587c60d221240691dcd">More...</a><br/></td></tr>
<tr class="separator:ga825412a3746ef587c60d221240691dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab039839654af96fbcb810b68f4665242"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gab039839654af96fbcb810b68f4665242">sd_power_reset_reason_get</a> (uint32_t *p_reset_reason)</td></tr>
<tr class="memdesc:gab039839654af96fbcb810b68f4665242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reset reason register.  <a href="#gab039839654af96fbcb810b68f4665242">More...</a><br/></td></tr>
<tr class="separator:gab039839654af96fbcb810b68f4665242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga35ec66682cd00c0a51c1e8552a285dd2">sd_power_reset_reason_clr</a> (uint32_t reset_reason_clr_msk)</td></tr>
<tr class="memdesc:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the bits of the reset reason register.  <a href="#ga35ec66682cd00c0a51c1e8552a285dd2">More...</a><br/></td></tr>
<tr class="separator:ga35ec66682cd00c0a51c1e8552a285dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb23d3ce98ba3afa1c3fa2b06d49491"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga5bb23d3ce98ba3afa1c3fa2b06d49491">sd_power_mode_set</a> (uint8_t power_mode)</td></tr>
<tr class="memdesc:ga5bb23d3ce98ba3afa1c3fa2b06d49491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the power mode when in CPU sleep.  <a href="#ga5bb23d3ce98ba3afa1c3fa2b06d49491">More...</a><br/></td></tr>
<tr class="separator:ga5bb23d3ce98ba3afa1c3fa2b06d49491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga774947ee0e200456ea3aec3fc7f8bd6b">sd_power_system_off</a> (void)</td></tr>
<tr class="memdesc:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the chip in System OFF mode.  <a href="#ga774947ee0e200456ea3aec3fc7f8bd6b">More...</a><br/></td></tr>
<tr class="separator:ga774947ee0e200456ea3aec3fc7f8bd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac38acbdbcaf059d562e2c600b1acb059"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gac38acbdbcaf059d562e2c600b1acb059">sd_power_pof_enable</a> (uint8_t pof_enable)</td></tr>
<tr class="memdesc:gac38acbdbcaf059d562e2c600b1acb059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables the power-fail comparator.  <a href="#gac38acbdbcaf059d562e2c600b1acb059">More...</a><br/></td></tr>
<tr class="separator:gac38acbdbcaf059d562e2c600b1acb059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10681c54678c912fb81aa20e889d4282"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga10681c54678c912fb81aa20e889d4282">sd_power_pof_threshold_set</a> (uint8_t threshold)</td></tr>
<tr class="memdesc:ga10681c54678c912fb81aa20e889d4282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the power failure comparator threshold value.  <a href="#ga10681c54678c912fb81aa20e889d4282">More...</a><br/></td></tr>
<tr class="separator:ga10681c54678c912fb81aa20e889d4282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f1c3f64a4c56f2f6109e214cac02912"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga9f1c3f64a4c56f2f6109e214cac02912">sd_power_ram_power_set</a> (uint8_t index, uint32_t ram_powerset)</td></tr>
<tr class="memdesc:ga9f1c3f64a4c56f2f6109e214cac02912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the NRF_POWER-&gt;RAM[index].POWERSET register.  <a href="#ga9f1c3f64a4c56f2f6109e214cac02912">More...</a><br/></td></tr>
<tr class="separator:ga9f1c3f64a4c56f2f6109e214cac02912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga694eedb9b5b5b4a775689c71ce07f45a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga694eedb9b5b5b4a775689c71ce07f45a">sd_power_ram_power_clr</a> (uint8_t index, uint32_t ram_powerclr)</td></tr>
<tr class="memdesc:ga694eedb9b5b5b4a775689c71ce07f45a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the NRF_POWER-&gt;RAM[index].POWERCLR register.  <a href="#ga694eedb9b5b5b4a775689c71ce07f45a">More...</a><br/></td></tr>
<tr class="separator:ga694eedb9b5b5b4a775689c71ce07f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82926fd68134fb445ea3b4f37aeec3c2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga82926fd68134fb445ea3b4f37aeec3c2">sd_power_ram_power_get</a> (uint8_t index, uint32_t *p_ram_power)</td></tr>
<tr class="memdesc:ga82926fd68134fb445ea3b4f37aeec3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents of NRF_POWER-&gt;RAM[index].POWER register, indicates power status of RAM[index] blocks.  <a href="#ga82926fd68134fb445ea3b4f37aeec3c2">More...</a><br/></td></tr>
<tr class="separator:ga82926fd68134fb445ea3b4f37aeec3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62737e6515d380aa3eeba6582d061592"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga62737e6515d380aa3eeba6582d061592">sd_power_gpregret_set</a> (uint32_t gpregret_id, uint32_t gpregret_msk)</td></tr>
<tr class="memdesc:ga62737e6515d380aa3eeba6582d061592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set bits in the general purpose retention registers (NRF_POWER-&gt;GPREGRET*).  <a href="#ga62737e6515d380aa3eeba6582d061592">More...</a><br/></td></tr>
<tr class="separator:ga62737e6515d380aa3eeba6582d061592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e54b3ddb041eb0126f6f7efa420183"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga56e54b3ddb041eb0126f6f7efa420183">sd_power_gpregret_clr</a> (uint32_t gpregret_id, uint32_t gpregret_msk)</td></tr>
<tr class="memdesc:ga56e54b3ddb041eb0126f6f7efa420183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear bits in the general purpose retention registers (NRF_POWER-&gt;GPREGRET*).  <a href="#ga56e54b3ddb041eb0126f6f7efa420183">More...</a><br/></td></tr>
<tr class="separator:ga56e54b3ddb041eb0126f6f7efa420183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f556952ace85b095861f06dcdaa2e0"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga99f556952ace85b095861f06dcdaa2e0">sd_power_gpregret_get</a> (uint32_t gpregret_id, uint32_t *p_gpregret)</td></tr>
<tr class="memdesc:ga99f556952ace85b095861f06dcdaa2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contents of the general purpose retention registers (NRF_POWER-&gt;GPREGRET*).  <a href="#ga99f556952ace85b095861f06dcdaa2e0">More...</a><br/></td></tr>
<tr class="separator:ga99f556952ace85b095861f06dcdaa2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84bd6a0e8f55a7aa85a5ec608edd61fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga84bd6a0e8f55a7aa85a5ec608edd61fe">sd_power_dcdc_mode_set</a> (uint8_t dcdc_mode)</td></tr>
<tr class="memdesc:ga84bd6a0e8f55a7aa85a5ec608edd61fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the DC/DC regulator.  <a href="#ga84bd6a0e8f55a7aa85a5ec608edd61fe">More...</a><br/></td></tr>
<tr class="separator:ga84bd6a0e8f55a7aa85a5ec608edd61fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5afb495a1b0307c749cc268df94a74"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga3e5afb495a1b0307c749cc268df94a74">sd_clock_hfclk_request</a> (void)</td></tr>
<tr class="memdesc:ga3e5afb495a1b0307c749cc268df94a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the high frequency crystal oscillator.  <a href="#ga3e5afb495a1b0307c749cc268df94a74">More...</a><br/></td></tr>
<tr class="separator:ga3e5afb495a1b0307c749cc268df94a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga7dcec5b896ce32fe70e9b54d7b523f55">sd_clock_hfclk_release</a> (void)</td></tr>
<tr class="memdesc:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the high frequency crystal oscillator.  <a href="#ga7dcec5b896ce32fe70e9b54d7b523f55">More...</a><br/></td></tr>
<tr class="separator:ga7dcec5b896ce32fe70e9b54d7b523f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga622439323dd33dbf6de9cf4508478d9e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga622439323dd33dbf6de9cf4508478d9e">sd_clock_hfclk_is_running</a> (uint32_t *p_is_running)</td></tr>
<tr class="memdesc:ga622439323dd33dbf6de9cf4508478d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the high frequency crystal oscillator is running.  <a href="#ga622439323dd33dbf6de9cf4508478d9e">More...</a><br/></td></tr>
<tr class="separator:ga622439323dd33dbf6de9cf4508478d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11d88d38ac99fb72cde74c9385d36433"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga11d88d38ac99fb72cde74c9385d36433">sd_app_evt_wait</a> (void)</td></tr>
<tr class="memdesc:ga11d88d38ac99fb72cde74c9385d36433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for an application event.  <a href="#ga11d88d38ac99fb72cde74c9385d36433">More...</a><br/></td></tr>
<tr class="separator:ga11d88d38ac99fb72cde74c9385d36433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaa4bca1d649efaf344e264f1896b4e7d3">sd_ppi_channel_enable_get</a> (uint32_t *p_channel_enable)</td></tr>
<tr class="memdesc:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PPI channel enable register contents.  <a href="#gaa4bca1d649efaf344e264f1896b4e7d3">More...</a><br/></td></tr>
<tr class="separator:gaa4bca1d649efaf344e264f1896b4e7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa188454bfb10c800a14f21aa29ad84d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaa188454bfb10c800a14f21aa29ad84d9">sd_ppi_channel_enable_set</a> (uint32_t channel_enable_set_msk)</td></tr>
<tr class="memdesc:gaa188454bfb10c800a14f21aa29ad84d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PPI channel enable register.  <a href="#gaa188454bfb10c800a14f21aa29ad84d9">More...</a><br/></td></tr>
<tr class="separator:gaa188454bfb10c800a14f21aa29ad84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e14d647d82165871f137aa0e659146b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga6e14d647d82165871f137aa0e659146b">sd_ppi_channel_enable_clr</a> (uint32_t channel_enable_clr_msk)</td></tr>
<tr class="memdesc:ga6e14d647d82165871f137aa0e659146b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear PPI channel enable register.  <a href="#ga6e14d647d82165871f137aa0e659146b">More...</a><br/></td></tr>
<tr class="separator:ga6e14d647d82165871f137aa0e659146b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gab1ca9bfe70cf943a6290516ddceb0a0f">sd_ppi_channel_assign</a> (uint8_t channel_num, const volatile void *evt_endpoint, const volatile void *task_endpoint)</td></tr>
<tr class="memdesc:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign endpoints to a PPI channel.  <a href="#gab1ca9bfe70cf943a6290516ddceb0a0f">More...</a><br/></td></tr>
<tr class="separator:gab1ca9bfe70cf943a6290516ddceb0a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gab42a29d65cf407dbd4bd5f81bc56b897">sd_ppi_group_task_enable</a> (uint8_t group_num)</td></tr>
<tr class="memdesc:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task to enable a channel group.  <a href="#gab42a29d65cf407dbd4bd5f81bc56b897">More...</a><br/></td></tr>
<tr class="separator:gab42a29d65cf407dbd4bd5f81bc56b897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaea3bb00707d4209992d34bc7d7c2223"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaaea3bb00707d4209992d34bc7d7c2223">sd_ppi_group_task_disable</a> (uint8_t group_num)</td></tr>
<tr class="memdesc:gaaea3bb00707d4209992d34bc7d7c2223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task to disable a channel group.  <a href="#gaaea3bb00707d4209992d34bc7d7c2223">More...</a><br/></td></tr>
<tr class="separator:gaaea3bb00707d4209992d34bc7d7c2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga178d4a905142c88dc7a8ce3635738313"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga178d4a905142c88dc7a8ce3635738313">sd_ppi_group_assign</a> (uint8_t group_num, uint32_t channel_msk)</td></tr>
<tr class="memdesc:ga178d4a905142c88dc7a8ce3635738313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign PPI channels to a channel group.  <a href="#ga178d4a905142c88dc7a8ce3635738313">More...</a><br/></td></tr>
<tr class="separator:ga178d4a905142c88dc7a8ce3635738313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gaf8c5ad47f11322c53a18e2e662234bc3">sd_ppi_group_get</a> (uint8_t group_num, uint32_t *p_channel_msk)</td></tr>
<tr class="memdesc:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the PPI channels of a channel group.  <a href="#gaf8c5ad47f11322c53a18e2e662234bc3">More...</a><br/></td></tr>
<tr class="separator:gaf8c5ad47f11322c53a18e2e662234bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2dc8aae2c68a2afa1a77340ad59d789"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gac2dc8aae2c68a2afa1a77340ad59d789">sd_radio_notification_cfg_set</a> (uint8_t type, uint8_t distance)</td></tr>
<tr class="memdesc:gac2dc8aae2c68a2afa1a77340ad59d789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the Radio Notification signal.  <a href="#gac2dc8aae2c68a2afa1a77340ad59d789">More...</a><br/></td></tr>
<tr class="separator:gac2dc8aae2c68a2afa1a77340ad59d789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79280d697e7ba03810c6473b0c7dab87"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga79280d697e7ba03810c6473b0c7dab87">sd_ecb_block_encrypt</a> (<a class="el" href="structnrf__ecb__hal__data__t.html">nrf_ecb_hal_data_t</a> *p_ecb_data)</td></tr>
<tr class="memdesc:ga79280d697e7ba03810c6473b0c7dab87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts a block according to the specified parameters.  <a href="#ga79280d697e7ba03810c6473b0c7dab87">More...</a><br/></td></tr>
<tr class="separator:ga79280d697e7ba03810c6473b0c7dab87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30cc707e7aa4a73019fae00f8b4faa52"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga30cc707e7aa4a73019fae00f8b4faa52">sd_ecb_blocks_encrypt</a> (uint8_t block_count, <a class="el" href="structnrf__ecb__hal__data__block__t.html">nrf_ecb_hal_data_block_t</a> *p_data_blocks)</td></tr>
<tr class="memdesc:ga30cc707e7aa4a73019fae00f8b4faa52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypts multiple data blocks provided as an array of data block structures.  <a href="#ga30cc707e7aa4a73019fae00f8b4faa52">More...</a><br/></td></tr>
<tr class="separator:ga30cc707e7aa4a73019fae00f8b4faa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga8bb3db4bb663fe6deb65f92f1f0cbbcc">sd_evt_get</a> (uint32_t *p_evt_id)</td></tr>
<tr class="memdesc:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets any pending events generated by the SoC API.  <a href="#ga8bb3db4bb663fe6deb65f92f1f0cbbcc">More...</a><br/></td></tr>
<tr class="separator:ga8bb3db4bb663fe6deb65f92f1f0cbbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0ea69f513ff1feab2c4f6e1c393313"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gade0ea69f513ff1feab2c4f6e1c393313">sd_temp_get</a> (int32_t *p_temp)</td></tr>
<tr class="memdesc:gade0ea69f513ff1feab2c4f6e1c393313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temperature measured on the chip.  <a href="#gade0ea69f513ff1feab2c4f6e1c393313">More...</a><br/></td></tr>
<tr class="separator:gade0ea69f513ff1feab2c4f6e1c393313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5361e65cbb5e7f6e258947a394c9b55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gae5361e65cbb5e7f6e258947a394c9b55">sd_flash_write</a> (uint32_t *p_dst, uint32_t const *p_src, uint32_t size)</td></tr>
<tr class="memdesc:gae5361e65cbb5e7f6e258947a394c9b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Write.  <a href="#gae5361e65cbb5e7f6e258947a394c9b55">More...</a><br/></td></tr>
<tr class="separator:gae5361e65cbb5e7f6e258947a394c9b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga9c93dd94a138ad8b5ed3693ea38ffb3e">sd_flash_page_erase</a> (uint32_t page_number)</td></tr>
<tr class="memdesc:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Erase page.  <a href="#ga9c93dd94a138ad8b5ed3693ea38ffb3e">More...</a><br/></td></tr>
<tr class="separator:ga9c93dd94a138ad8b5ed3693ea38ffb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6c5b029494663d62783ace862b99d5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gadf6c5b029494663d62783ace862b99d5">sd_flash_protect</a> (uint32_t block_cfg0, uint32_t block_cfg1, uint32_t block_cfg2, uint32_t block_cfg3)</td></tr>
<tr class="memdesc:gadf6c5b029494663d62783ace862b99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flash Protection set.  <a href="#gadf6c5b029494663d62783ace862b99d5">More...</a><br/></td></tr>
<tr class="separator:gadf6c5b029494663d62783ace862b99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga55a52eb4d0491cb7105de6a13eb2b11b">sd_radio_session_open</a> (<a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaf5319fc8ecbc011eca84a187f0a4da54">nrf_radio_signal_callback_t</a> p_radio_signal_callback)</td></tr>
<tr class="memdesc:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a session for radio timeslot requests.  <a href="#ga55a52eb4d0491cb7105de6a13eb2b11b">More...</a><br/></td></tr>
<tr class="separator:ga55a52eb4d0491cb7105de6a13eb2b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcc6027a70aecaaa27e4deec6231f999"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gabcc6027a70aecaaa27e4deec6231f999">sd_radio_session_close</a> (void)</td></tr>
<tr class="memdesc:gabcc6027a70aecaaa27e4deec6231f999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a session for radio timeslot requests.  <a href="#gabcc6027a70aecaaa27e4deec6231f999">More...</a><br/></td></tr>
<tr class="separator:gabcc6027a70aecaaa27e4deec6231f999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbd3ade121c15745cc19b900ce8154b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga3fbd3ade121c15745cc19b900ce8154b">sd_radio_request</a> (<a class="el" href="structnrf__radio__request__t.html">nrf_radio_request_t</a> const *p_request)</td></tr>
<tr class="memdesc:ga3fbd3ade121c15745cc19b900ce8154b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests a radio timeslot.  <a href="#ga3fbd3ade121c15745cc19b900ce8154b">More...</a><br/></td></tr>
<tr class="separator:ga3fbd3ade121c15745cc19b900ce8154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4297b1ba27883a54a3b1ac806415949"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gab4297b1ba27883a54a3b1ac806415949">sd_protected_register_write</a> (volatile uint32_t *p_register, uint32_t value)</td></tr>
<tr class="memdesc:gab4297b1ba27883a54a3b1ac806415949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write register protected by the SoftDevice.  <a href="#gab4297b1ba27883a54a3b1ac806415949">More...</a><br/></td></tr>
<tr class="separator:gab4297b1ba27883a54a3b1ac806415949"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga11d88d38ac99fb72cde74c9385d36433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_app_evt_wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits for an application event. </p>
<p>An application event is either an application interrupt or a pended interrupt when the interrupt is disabled.</p>
<p>When the application waits for an application event by calling this function, an interrupt that is enabled will be taken immediately on pending since this function will wait in thread mode, then the execution will return in the application's main thread.</p>
<p>In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M MCU's System Control Register (SCR), CMSIS_SCB. In that case, when a disabled interrupt gets pended, this function will return to the application's main thread.</p>
<dl class="section note"><dt>Note</dt><dd>The application must ensure that the pended flag is cleared using <a class="el" href="group___n_r_f___n_v_i_c___f_u_n_c_t_i_o_n_s.html#gaaab82d624bd21852288a3a6ad178cec7" title="Clear Pending Interrupt.">sd_nvic_ClearPendingIRQ</a> in order to sleep using this function. This is only necessary for disabled interrupts, as the interrupt handler will clear the pending flag automatically for enabled interrupts.</dd>
<dd>
If an application interrupt has happened since the last time sd_app_evt_wait was called this function will return immediately and not go to sleep. This is to avoid race conditions that can occur when a flag is updated in the interrupt handler and processed in the main loop.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>An application interrupt has happened or a interrupt pending flag is set.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga622439323dd33dbf6de9cf4508478d9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_is_running </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_is_running</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the high frequency crystal oscillator is running. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga3e5afb495a1b0307c749cc268df94a74" title="Request the high frequency crystal oscillator.">sd_clock_hfclk_request</a> </dd>
<dd>
<a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga7dcec5b896ce32fe70e9b54d7b523f55" title="Releases the high frequency crystal oscillator.">sd_clock_hfclk_release</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_is_running</td><td>1 if the external crystal oscillator is running, 0 if not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7dcec5b896ce32fe70e9b54d7b523f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_release </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the high frequency crystal oscillator. </p>
<p>Will stop the high frequency crystal oscillator, this happens immediately.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> </dd>
<dd>
<a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga3e5afb495a1b0307c749cc268df94a74" title="Request the high frequency crystal oscillator.">sd_clock_hfclk_request</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e5afb495a1b0307c749cc268df94a74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_clock_hfclk_request </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the high frequency crystal oscillator. </p>
<p>Will start the high frequency crystal oscillator, the startup time of the crystal varies and the <a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> function can be polled to check if it has started.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga622439323dd33dbf6de9cf4508478d9e" title="Checks if the high frequency crystal oscillator is running.">sd_clock_hfclk_is_running</a> </dd>
<dd>
<a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga7dcec5b896ce32fe70e9b54d7b523f55" title="Releases the high frequency crystal oscillator.">sd_clock_hfclk_release</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga79280d697e7ba03810c6473b0c7dab87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ecb_block_encrypt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__ecb__hal__data__t.html">nrf_ecb_hal_data_t</a> *&#160;</td>
          <td class="paramname"><em>p_ecb_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypts a block according to the specified parameters. </p>
<p>128-bit AES encryption.</p>
<dl class="section note"><dt>Note</dt><dd>:<ul>
<li>The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application main or low interrupt level.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_ecb_data</td><td>Pointer to the ECB parameters' struct (two input parameters and one output parameter).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30cc707e7aa4a73019fae00f8b4faa52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ecb_blocks_encrypt </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__ecb__hal__data__block__t.html">nrf_ecb_hal_data_block_t</a> *&#160;</td>
          <td class="paramname"><em>p_data_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypts multiple data blocks provided as an array of data block structures. </p>
<p>: Performs 128-bit AES encryption on multiple data blocks</p>
<dl class="section note"><dt>Note</dt><dd>:<ul>
<li>The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice sleep while the ECB is running. The SEVONPEND bit should only be cleared (set to 0) from application main or low interrupt level.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block_count</td><td>Count of blocks in the p_data_blocks array. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_data_blocks</td><td>Pointer to the first entry in a contiguous array of <a class="el" href="structnrf__ecb__hal__data__block__t.html">nrf_ecb_hal_data_block_t</a> structures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8bb3db4bb663fe6deb65f92f1f0cbbcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_evt_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_evt_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets any pending events generated by the SoC API. </p>
<p>The application should keep calling this function to get events, until <a class="el" href="group__nrf__error.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_evt_id</td><td>Set to one of the values in <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga2a3d2f55035ee3173aff0c05465fb648">NRF_SOC_EVTS</a>, if any events are pending.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>An event was pending. The event id is written in the p_evt_id parameter. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga349d25ada15be023e0d507f45ada682c" title="Not found.">NRF_ERROR_NOT_FOUND</a></td><td>No pending events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9c93dd94a138ad8b5ed3693ea38ffb3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_page_erase </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Erase page. </p>
<p>Commands to erase a flash page If the SoftDevice is enabled: This call initiates the flash access command, and its completion will be communicated to the application with exactly one of the following events:</p>
<ul>
<li><a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a566ef9d8a97914dd30cd152bdfcd50e6">NRF_EVT_FLASH_OPERATION_SUCCESS</a> - The command was successfully completed.</li>
<li><a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a7c0083f76ab9ee6e75369776526d584d">NRF_EVT_FLASH_OPERATION_ERROR</a> - The command could not be started.</li>
</ul>
<p>If the SoftDevice is not enabled no event will be generated, and this call will return <a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a> when the erase has been completed</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This call takes control over the radio and the CPU during flash erase and write to make sure that they will not interfere with the flash access. This means that all interrupts will be blocked for a predictable time (depending on the NVMC specification in the device's Product Specification and the command parameters).</li>
<li>This call will make the SoftDevice trigger a hardfault when the page is erased, if it is protected.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_number</td><td>Page number of the page to erase</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gadf8b0c33ea15352808e5ac7f69c2be8a" title="Internal Error.">NRF_ERROR_INTERNAL</a></td><td>If a new session could not be opened due to an internal error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>Tried to erase to a non existing flash page. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>The previous command has not yet completed. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Tried to erase a page outside the application flash area. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The command was accepted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf6c5b029494663d62783ace862b99d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_protect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_cfg0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_cfg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_cfg2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_cfg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Protection set. </p>
<p>Commands to set the flash protection configuration registers. This sets the CONFIGx registers of the BPROT peripheral.</p>
<dl class="section note"><dt>Note</dt><dd>Not all parameters are valid for all products. Some bits in each parameter may not be valid for your product. Please refer your Product Specification for more details.</dd>
<dd>
To read the values read them directly. They are only write-protected.</dd>
<dd>
It is possible to use <a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#gab4297b1ba27883a54a3b1ac806415949">sd_protected_register_write</a> instead of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block_cfg0</td><td>Value to be written to the configuration register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_cfg1</td><td>Value to be written to the configuration register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_cfg2</td><td>Value to be written to the configuration register. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block_cfg3</td><td>Value to be written to the configuration register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138" title="Not supported.">NRF_ERROR_NOT_SUPPORTED</a></td><td>Non-zero value supplied to one or more of the unsupported parameters. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Values successfully written to configuration registers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae5361e65cbb5e7f6e258947a394c9b55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_flash_write </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flash Write. </p>
<p>Commands to write a buffer to flash</p>
<p>If the SoftDevice is enabled: This call initiates the flash access command, and its completion will be communicated to the application with exactly one of the following events:</p>
<ul>
<li><a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a566ef9d8a97914dd30cd152bdfcd50e6">NRF_EVT_FLASH_OPERATION_SUCCESS</a> - The command was successfully completed.</li>
<li><a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a7c0083f76ab9ee6e75369776526d584d">NRF_EVT_FLASH_OPERATION_ERROR</a> - The command could not be started.</li>
</ul>
<p>If the SoftDevice is not enabled no event will be generated, and this call will return <a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a> when the write has been completed</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>This call takes control over the radio and the CPU during flash erase and write to make sure that they will not interfere with the flash access. This means that all interrupts will be blocked for a predictable time (depending on the NVMC specification in the device's Product Specification and the command parameters).</li>
<li>The data in the p_src buffer should not be modified before the <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a566ef9d8a97914dd30cd152bdfcd50e6">NRF_EVT_FLASH_OPERATION_SUCCESS</a> or the <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a7c0083f76ab9ee6e75369776526d584d">NRF_EVT_FLASH_OPERATION_ERROR</a> have been received if the SoftDevice is enabled.</li>
<li>This call will make the SoftDevice trigger a hardfault when the page is written, if it is protected.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dst</td><td>Pointer to start of flash location to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Pointer to buffer with data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of 32-bit words to write. Maximum size is the number of words in one flash page. See the device's Product Specification for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>Tried to write to a non existing flash address, or p_dst or p_src was unaligned. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>The previous command has not yet completed. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga59fe2a8fe184005aefa0835c7ff400fd" title="Invalid Length.">NRF_ERROR_INVALID_LENGTH</a></td><td>Size was 0, or higher than the maximum allowed size. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Tried to write to an address outside the application flash area. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The command was accepted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa1407f50bb45705fea4b2bfee5ff01d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to acquire a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to acquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The mutex was successfully acquired. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga08505c75d1cc68c75b2b529f0acfd9e7" title="Mutex already taken.">NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN</a></td><td>The mutex could not be acquired. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga17b2cdfc1c0efb4a25bcc75aeb0c9b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaccdf301739ba049b9ec635832120573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_mutex_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaa1ec46ac9de000227852834ec1ff86ea">nrf_mutex_t</a> *&#160;</td>
          <td class="paramname"><em>p_mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_mutex</td><td>Pointer to the mutex to release.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga84bd6a0e8f55a7aa85a5ec608edd61fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_dcdc_mode_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dcdc_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the DC/DC regulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dcdc_mode</td><td>The mode of the DCDC, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga0c5eb0d4a7014099e3410521358585a7">NRF_POWER_DCDC_MODES</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>The DCDC mode is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga56e54b3ddb041eb0126f6f7efa420183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear bits in the general purpose retention registers (NRF_POWER-&gt;GPREGRET*). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_id</td><td>0 for GPREGRET, 1 for GPREGRET2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_msk</td><td>Bits to be clear in the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga99f556952ace85b095861f06dcdaa2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_gpregret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents of the general purpose retention registers (NRF_POWER-&gt;GPREGRET*). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_id</td><td>0 for GPREGRET, 1 for GPREGRET2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_gpregret</td><td>Contents of the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga62737e6515d380aa3eeba6582d061592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_gpregret_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpregret_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set bits in the general purpose retention registers (NRF_POWER-&gt;GPREGRET*). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_id</td><td>0 for GPREGRET, 1 for GPREGRET2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpregret_msk</td><td>Bits to be set in the GPREGRET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5bb23d3ce98ba3afa1c3fa2b06d49491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_mode_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>power_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the power mode when in CPU sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power_mode</td><td>The power mode to use when in CPU sleep, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga66c4a4f3902bf8dfd3751c32e6589790">NRF_POWER_MODES</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga11d88d38ac99fb72cde74c9385d36433" title="Waits for an application event.">sd_app_evt_wait</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The power mode was set. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#gaba78285df6e85daaa153bce5890364df" title="Power mode unknown.">NRF_ERROR_SOC_POWER_MODE_UNKNOWN</a></td><td>The power mode was unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac38acbdbcaf059d562e2c600b1acb059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_pof_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>pof_enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables the power-fail comparator. </p>
<p>Enabling this will give a SoftDevice event (NRF_EVT_POWER_FAILURE_WARNING) when the power failure warning occurs. The event can be retrieved with <a class="el" href="group___n_r_f___s_o_c___f_u_n_c_t_i_o_n_s.html#ga8bb3db4bb663fe6deb65f92f1f0cbbcc" title="Gets any pending events generated by the SoC API.">sd_evt_get()</a>;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pof_enable</td><td>True if the power-fail comparator should be enabled, false if it should be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10681c54678c912fb81aa20e889d4282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_pof_threshold_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the power failure comparator threshold value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>The power-fail threshold value to use, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga3632f2fdc715316bd5c227fab6e17b90">NRF_POWER_THRESHOLDS</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The power failure threshold was set. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga4c66885f407427c323d19539f6e59e0d" title="Power POF threshold unknown.">NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN</a></td><td>The power failure threshold is unknown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga694eedb9b5b5b4a775689c71ce07f45a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ram_power_clr </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ram_powerclr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the NRF_POWER-&gt;RAM[index].POWERCLR register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Contains the index in the NRF_POWER-&gt;RAM[index].POWERCLR register to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ram_powerclr</td><td>Contains the word to write to the NRF_POWER-&gt;RAM[index].POWERCLR register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga82926fd68134fb445ea3b4f37aeec3c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ram_power_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_ram_power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get contents of NRF_POWER-&gt;RAM[index].POWER register, indicates power status of RAM[index] blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Contains the index in the NRF_POWER-&gt;RAM[index].POWER register to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_ram_power</td><td>Content of NRF_POWER-&gt;RAM[index].POWER register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f1c3f64a4c56f2f6109e214cac02912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_ram_power_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ram_powerset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the NRF_POWER-&gt;RAM[index].POWERSET register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Contains the index in the NRF_POWER-&gt;RAM[index].POWERSET register to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ram_powerset</td><td>Contains the word to write to the NRF_POWER-&gt;RAM[index].POWERSET register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga35ec66682cd00c0a51c1e8552a285dd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_reset_reason_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reset_reason_clr_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the bits of the reset reason register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reset_reason_clr_msk</td><td>Contains the bits to clear from the reset reason register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab039839654af96fbcb810b68f4665242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_reset_reason_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_reset_reason</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the reset reason register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_reset_reason</td><td>Contents of the NRF_POWER-&gt;RESETREAS register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga774947ee0e200456ea3aec3fc7f8bd6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_power_system_off </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the chip in System OFF mode. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga57d53aa15592b0bfacc98d99c4dda07b" title="Power off should not return.">NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab1ca9bfe70cf943a6290516ddceb0a0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>channel_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void *&#160;</td>
          <td class="paramname"><em>evt_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void *&#160;</td>
          <td class="paramname"><em>task_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign endpoints to a PPI channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_num</td><td>Number of the PPI channel to assign. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evt_endpoint</td><td>Event endpoint of the PPI channel. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task_endpoint</td><td>Task endpoint of the PPI channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga563fa0ece398152e3256b09da51fda7f" title="Invalid PPI Channel.">NRF_ERROR_SOC_PPI_INVALID_CHANNEL</a></td><td>The channel number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e14d647d82165871f137aa0e659146b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_clr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_enable_clr_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear PPI channel enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_enable_clr_msk</td><td>Mask containing the bits to clear in the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa4bca1d649efaf344e264f1896b4e7d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_get </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_channel_enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get PPI channel enable register contents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_channel_enable</td><td>The contents of the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa188454bfb10c800a14f21aa29ad84d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_channel_enable_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_enable_set_msk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PPI channel enable register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_enable_set_msk</td><td>Mask containing the bits to set in the PPI CHEN register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga178d4a905142c88dc7a8ce3635738313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_assign </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>channel_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign PPI channels to a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_msk</td><td>Mask of the channels to assign to the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8c5ad47f11322c53a18e2e662234bc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_channel_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the PPI channels of a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_channel_msk</td><td>Mask of the channels assigned to the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaaea3bb00707d4209992d34bc7d7c2223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_task_disable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task to disable a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the PPI group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab42a29d65cf407dbd4bd5f81bc56b897"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_ppi_group_task_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>group_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task to enable a channel group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_num</td><td>Number of the channel group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#ga78bb614cb480357c7cb191ec8efba5fb" title="Invalid PPI Group.">NRF_ERROR_SOC_PPI_INVALID_GROUP</a></td><td>The group number is invalid </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab4297b1ba27883a54a3b1ac806415949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_protected_register_write </td>
          <td>(</td>
          <td class="paramtype">volatile uint32_t *&#160;</td>
          <td class="paramname"><em>p_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write register protected by the SoftDevice. </p>
<p>This function writes to a register that is write-protected by the SoftDevice. Please refer to your SoftDevice Specification for more details about which registers that are protected by SoftDevice. This function can write to the following protected peripheral:</p>
<ul>
<li>BPROT</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Protected registers may be read directly. </dd>
<dd>
Register that are write-once will return <a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a> on second set, even the value in the register has not changed. See the Product Specification for more details about register properties.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_register</td><td>Pointer to register to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>This function can not write to the reguested register. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Value successfully written to register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac2dc8aae2c68a2afa1a77340ad59d789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_notification_cfg_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the Radio Notification signal. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The notification signal latency depends on the interrupt priority settings of SWI used for notification signal.</li>
<li>To ensure that the radio notification signal behaves in a consistent way, the radio notifications must be configured when there is no protocol stack or other SoftDevice activity in progress. It is recommended that the radio notification signal is configured directly after the SoftDevice has been enabled.</li>
<li>In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice will interrupt the application to do Radio Event preparation.</li>
<li>Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have to shorten the connection events to have time for the Radio Notification signals.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Type of notification signal, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga20a90837e52ffbde1fb2ad81ef2db8c8">NRF_RADIO_NOTIFICATION_TYPES</a>. <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a> shall be used to turn off radio notification. Using <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga59b1a77ef6dcb1d75833e5c5f5251d58a8c14977e62861ab59d8d757c084cbac8">NRF_RADIO_NOTIFICATION_DISTANCE_NONE</a> is recommended (but not required) to be used with <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance</td><td>Distance between the notification signal and start of radio activity, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga59b1a77ef6dcb1d75833e5c5f5251d58">NRF_RADIO_NOTIFICATION_DISTANCES</a>. This parameter is ignored when <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga20a90837e52ffbde1fb2ad81ef2db8c8ac01e4b09fe151987651c1825c1259276">NRF_RADIO_NOTIFICATION_TYPE_NONE</a> or <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga20a90837e52ffbde1fb2ad81ef2db8c8a37db2f7d40ca9532eebff7f8c46b5a86">NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE</a> is used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>The group number is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gaf0aff2ba7864b34a36b4a96986e1851e" title="Invalid state, operation disallowed in this state.">NRF_ERROR_INVALID_STATE</a></td><td>A protocol stack or other SoftDevice is running. Stop all running activities and retry. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fbd3ade121c15745cc19b900ce8154b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__radio__request__t.html">nrf_radio_request_t</a> const *&#160;</td>
          <td class="paramname"><em>p_request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests a radio timeslot. </p>
<dl class="section note"><dt>Note</dt><dd>The request type is determined by p_request-&gt;request_type, and can be one of <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a> and <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a23233e911f0964d33440620f8965497a">NRF_RADIO_REQ_TYPE_NORMAL</a>. The first request in a session must always be of type <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a>. </dd>
<dd>
For a normal request (<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a23233e911f0964d33440620f8965497a">NRF_RADIO_REQ_TYPE_NORMAL</a>), the start time of a radio timeslot is specified by p_request-&gt;distance_us and is given relative to the start of the previous timeslot. </dd>
<dd>
A too small p_request-&gt;distance_us will lead to a <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event. </dd>
<dd>
Timeslots scheduled too close will lead to a <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event. </dd>
<dd>
See the SoftDevice Specification for more on radio timeslot scheduling, distances and lengths. </dd>
<dd>
If an opportunity for the first radio timeslot is not found before 100 ms after the call to this function, it is not scheduled, and instead a <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event is sent. The application may then try to schedule the first radio timeslot again. </dd>
<dd>
Successful requests will result in nrf_radio_signal_callback_t(<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>). Unsuccessful requests will result in a <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a831ae39db7fcc9e63d66d87029a424d0">NRF_EVT_RADIO_BLOCKED</a> event, see <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#ga2a3d2f55035ee3173aff0c05465fb648">NRF_SOC_EVTS</a>. </dd>
<dd>
The jitter in the start time of the radio timeslots is +/- <a class="el" href="group___n_r_f___s_o_c___d_e_f_i_n_e_s.html#gaee821fbae999c3f4a8429b76ecbdead8">NRF_RADIO_START_JITTER_US</a> us. </dd>
<dd>
The nrf_radio_signal_callback_t(<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>) call has a latency relative to the specified radio timeslot start, but this does not affect the actual start time of the timeslot. </dd>
<dd>
NRF_TIMER0 is reset at the start of the radio timeslot, and is clocked at 1MHz from the high frequency (16 MHz) clock source. If p_request-&gt;hfclk_force_xtal is true, the high frequency clock is guaranteed to be clocked from the external crystal. </dd>
<dd>
The SoftDevice will neither access the NRF_RADIO peripheral nor the NRF_TIMER0 peripheral during the radio timeslot.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_request</td><td>Pointer to the request parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>Either:<ul>
<li>The session is not open.</li>
<li>The session is not IDLE.</li>
<li>This is the first request and its type is not <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a>.</li>
<li>The request type was set to <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a23233e911f0964d33440620f8965497a">NRF_RADIO_REQ_TYPE_NORMAL</a> after a <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga1d048df14a3eeef46aabec45e9643858a7951b0d09e47ff7d013fa506890ba42f">NRF_RADIO_REQ_TYPE_EARLIEST</a> request was blocked. </li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>If the p_request pointer is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga0a5831cf5092e0dd43a01869676ee076" title="Invalid Parameter.">NRF_ERROR_INVALID_PARAM</a></td><td>If the parameters of p_request are not valid. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabcc6027a70aecaaa27e4deec6231f999"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_session_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a session for radio timeslot requests. </p>
<dl class="section note"><dt>Note</dt><dd>Any current radio timeslot will be finished before the session is closed. </dd>
<dd>
If a radio timeslot is scheduled when the session is closed, it will be canceled. </dd>
<dd>
The application cannot consider the session closed until the <a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2a3d2f55035ee3173aff0c05465fb648a9ac39a4402cf55b86a44fc3bedd829b1">NRF_EVT_RADIO_SESSION_CLOSED</a> event is received.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga85125dae5d7e9d4b9964acbc13f641b3" title="Forbidden Operation.">NRF_ERROR_FORBIDDEN</a></td><td>If session not opened. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>If session is currently being closed. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga55a52eb4d0491cb7105de6a13eb2b11b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_radio_session_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___n_r_f___s_o_c___s_t_r_u_c_t_u_r_e_s.html#gaf5319fc8ecbc011eca84a187f0a4da54">nrf_radio_signal_callback_t</a>&#160;</td>
          <td class="paramname"><em>p_radio_signal_callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a session for radio timeslot requests. </p>
<dl class="section note"><dt>Note</dt><dd>Only one session can be open at a time. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2ecc6b5725b5075c2fc282d8f5b801b3ac1d8eef43f89255a395eca327086b5f8">NRF_RADIO_CALLBACK_SIGNAL_TYPE_START</a>) will be called when the radio timeslot starts. From this point the NRF_RADIO and NRF_TIMER0 peripherals can be freely accessed by the application. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2ecc6b5725b5075c2fc282d8f5b801b3a2ce5ff596372a7c8df4bbdd4654be02c">NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0</a>) is called whenever the NRF_TIMER0 interrupt occurs. </dd>
<dd>
p_radio_signal_callback(<a class="el" href="group___n_r_f___s_o_c___e_n_u_m_s.html#gga2ecc6b5725b5075c2fc282d8f5b801b3a7eedb8b9ee816cd21d1dc3ede51e07ae">NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO</a>) is called whenever the NRF_RADIO interrupt occurs. </dd>
<dd>
p_radio_signal_callback() will be called at ARM interrupt priority level 0. This implies that none of the sd_* API calls can be used from p_radio_signal_callback().</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_radio_signal_callback</td><td>The signal callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gabc562e4ddfe2f427666a3acdd0b469a3" title="Bad Memory Address.">NRF_ERROR_INVALID_ADDR</a></td><td>p_radio_signal_callback is an invalid function pointer. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga5d2d8608f6d6a0329f58961a969e946e" title="Busy.">NRF_ERROR_BUSY</a></td><td>If session cannot be opened. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#gadf8b0c33ea15352808e5ac7f69c2be8a" title="Internal Error.">NRF_ERROR_INTERNAL</a></td><td>If a new session could not be opened due to an internal error. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad12d1ebe6550185897326166e3d4591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_bytes_available_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_bytes_available</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of random bytes available to the application. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_bytes_available</td><td>The number of bytes currently available in the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e372c86c718f517174c53a611792489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_pool_capacity_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_pool_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the capacity of the application random pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_pool_capacity</td><td>The capacity of the pool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga825412a3746ef587c60d221240691dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_rand_application_vector_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get random bytes from the application pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_buff</td><td>Pointer to unit8_t buffer for storing the bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to take from pool and place in p_buff.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>The requested bytes were written to p_buff. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__nrf__soc__error.html#gabb7186c1f08507eecc60e99b569ee2f7" title="RAND not enough values.">NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES</a></td><td>No bytes were written to the buffer, because there were not enough bytes available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade0ea69f513ff1feab2c4f6e1c393313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sd_temp_get </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>p_temp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temperature measured on the chip. </p>
<p>This function will block until the temperature measurement is done. It takes around 50 us from call to return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_temp</td><td>Result of temperature measurement. Die temperature in 0.25 degrees Celsius.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname"><a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123" title="Successful command.">NRF_SUCCESS</a></td><td>A temperature measurement was done, and the temperature was written to temp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v17.0.2: Atomic FIFO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v17.0.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lib_atfifo.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Atomic FIFO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This implementation of the FIFO buffer allows accessing the data in the buffer atomically, from the main loop and interrupts, without the need of interrupt locking. The mechanism implemented here can be applied in an application in which access can be distributed between the main loop and any interrupts (with many levels). However, it will not work in an application where the FIFO access is distributed between different tasks in a multithreaded preemptive operating system.</p>
<h1><a class="anchor" id="lib_atfifo_usage"></a>
Usage</h1>
<p>Before you can use an instance of the FIFO, you must first create and initialize it.</p>
<div class="fragment"><div class="line"><a class="code" href="group__nrf__atfifo__instmacros.html#ga42b25062661bada560db0b3055b33956" title="Macro for creating an instance.">NRF_ATFIFO_DEF</a>(my_fifo, uint32_t, 16);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__nrf__atfifo__instmacros.html#ga26d17204e67d197f3f7db6594400a900" title="Macro for initializing the FIFO that was previously declared by the macro.">NRF_ATFIFO_INIT</a>(my_fifo);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Now my_fifo may be used</span></div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><p>The macro <a class="el" href="group__nrf__atfifo__instmacros.html#ga42b25062661bada560db0b3055b33956">NRF_ATFIFO_DEF</a> creates the FIFO buffer using the target data type. It means that the data in the buffer will be properly aligned in memory.</p>
<p>Writing to the FIFO is based on the following scheme:</p>
<ol type="1">
<li>Allocate - Reserve space in the FIFO buffer. The pointer to the buffer is returned.</li>
<li>Write item data - Write data using the returned pointer. In the simplest solution, you can use memcpy. However, data may be accessed in a more efficient way than byte-by-byte copying: <div class="fragment"><div class="line"><span class="keyword">struct </span>point</div>
<div class="line">{</div>
<div class="line">     <span class="keywordtype">int</span> x, y;</div>
<div class="line">}point_t;</div>
<div class="line"><a class="code" href="group__nrf__atfifo__instmacros.html#ga42b25062661bada560db0b3055b33956" title="Macro for creating an instance.">NRF_ATFIFO_DEF</a>(point_fifo, point_t, 16);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__nrf__atfifo__instmacros.html#ga26d17204e67d197f3f7db6594400a900" title="Macro for initializing the FIFO that was previously declared by the macro.">NRF_ATFIFO_INIT</a>(my_fifo);</div>
<div class="line"></div>
<div class="line">    nrf_atfifo_context_t context;</div>
<div class="line">    point_t * point;</div>
<div class="line">    <span class="keywordflow">if</span>(NULL != (point = <a class="code" href="group__nrf__atfifo.html#ga4e802cbd3e40c5821323636503347022" title="Function for opening the FIFO for writing.">nrf_atfifo_item_alloc</a>(point_fifo, &amp;context)))</div>
<div class="line">    {</div>
<div class="line">         <span class="comment">// Direct access to the fifo data</span></div>
<div class="line">         point-&gt;x = a;</div>
<div class="line">         point-&gt;y = b;</div>
<div class="line">         <span class="keywordflow">if</span>(<a class="code" href="group__nrf__atfifo.html#ga499c8507d73bfbb980ee3c31083c7a90" title="Function for closing the writing operation.">nrf_atfifo_item_put</a>(point_fifo, &amp;context))</div>
<div class="line">         {</div>
<div class="line">             <span class="comment">// Send information to the rest of the system</span></div>
<div class="line">             <span class="comment">// that there is new data in the FIFO available to read.</span></div>
<div class="line">         }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">         <span class="comment">// Error handling</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Put - Move the pointer of the data that is ready to be read. The <a class="el" href="group__nrf__atfifo.html#ga499c8507d73bfbb980ee3c31083c7a90">nrf_atfifo_item_put</a> function returns true if the data is currently visible. If it returns false, it means that the current FIFO access interrupts some other access, and the data will be available for reading when the interrupted access finishes.</li>
<li>Get - Give access to the variable in a buffer that is already available for reading. The read pointer is moved, but the free space pointer is left intact. It means that the data may be safely accessed until the Free operation on the item is finished. Then, the space in the buffer is released.</li>
<li>Process item data</li>
<li>Free</li>
</ol>
<p>Other simple instructions are also available, like <a class="el" href="group__nrf__atfifo.html#ga1839cb03bfdce755ec6f19e607a4ea07">nrf_atfifo_alloc_put</a> and <a class="el" href="group__nrf__atfifo.html#ga103e4642593210bf1f8bac61bc910980">nrf_atfifo_get_free</a>. They are using memcpy internally and take care of buffer allocation or freeing. In most cases, memcpy is less efficient than direct buffer access, but in simple usage, using them greatly limits code typing overhead.</p>
<h1><a class="anchor" id="lib_atfifo_reqs"></a>
Requirements</h1>
<p>This FIFO implementation requires the presence of LDREX and STREX instructions. The exclusive access instructions are not available in Cortex M0. It limits the usage of this atomic FIFO implementation to nRF52 only.</p>
<h1><a class="anchor" id="lib_atfifo_interrupt"></a>
Handling interruptions</h1>
<p>The implementation assumes that the possible interruption of FIFO access operation works like a stack. A task has to finish the whole access before exiting. It might be interrupted by another task, but this interrupting task must also finish its access. The following is the underlying mechanism of handling interruptions:</p>
<ol type="1">
<li><b>Task A</b> allocates space in FIFO.</li>
<li><b>Interrupt</b> interrupts the access and allocates space in FIFO.</li>
<li><b>Interrupt</b> pushes a new value into the allocated space.<ul>
<li>During pushing, it detects that access was interrupted before.</li>
<li>The new data is not available, but the space in the FIFO is reserved and data is present here.</li>
</ul>
</li>
<li><b>Task A</b> pushes data into the allocated space.<ul>
<li>During pushing, it detects that another piece of data is present.</li>
<li>Two new data items are available now.</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="lib_atfifo_multi"></a>
Multithreaded preemptive operating system limitation</h1>
<p>This kind of atomic FIFO access works well if access can be split between the main loop and any interrupts. It will not work however, if the FIFO access is distributed between different tasks in a multithreaded preemptive operating system. The problem with a multithreaded preemptive operating system is that the operation might be interrupted by another operation, which would not be finished before going back to the previous operation. For example:</p>
<ol type="1">
<li><b>Task A</b> allocates space in FIFO.</li>
<li><b>Task B</b> interrupts and allocates space in FIFO.</li>
<li><b>Task A</b> interrupts and pushes data into the FIFO. A problem arises:<ul>
<li><b>Task A</b> detects that there is new data in the FIFO.</li>
<li><b>Task A</b> marks two pieces of data available - the one from <b>Task A</b> and the one from <b>Task B</b>.</li>
<li>However, there is no valid data from <b>Task B</b> as the space was only booked and no data was set.</li>
</ul>
</li>
<li><b>Task B</b> interrupts and pushes its data. Now the FIFO state is valid, but there was a moment when data was corrupted.</li>
</ol>
<h1><a class="anchor" id="lib_atfifo_implementation"></a>
Implementation details</h1>
<p>For a simple FIFO, two indexes are remembered: tail and head. Tail is a pointer that keeps track of the historically last element in a list. Head is a pointer that keeps track of the first free space in a list. Thus, it points to an element just after the last stored value.</p>
<p>In the atomic FIFO implementation, these indices are not simple values. They are <a class="el" href="group__nrf__atfifo.html#ga04325c57e90d28bd20a26bda199646f8">nrf_atfifo_postag_t</a> structures. They holds read index and write index, 16 bits each. Together, they create a 32-bit value, which makes them available for single LDREX and STREX instructions. Each operation on this pair of read/write indices is run atomically. Therefore, even if the operation is interrupted while new indices are processed, they are just processed once again.</p>
<p>Every allocation moves only the write pointer, leaving the read pointer intact. During a push operation, if it is detected that the old read pointer equals the old write pointer, the read pointer is moved to the current write pointer. Because the implementation uses LDREX and STREX, it is possible to keep track of the fact that the processing during the copying was interrupted, so no data loss is possible at this point.</p>
<p>The old index is stored in operation context - compare it with <a class="el" href="group__nrf__atfifo.html#ga4e802cbd3e40c5821323636503347022">nrf_atfifo_item_alloc</a> and <a class="el" href="group__nrf__atfifo.html#ga499c8507d73bfbb980ee3c31083c7a90">nrf_atfifo_item_put</a>.</p>
<p>When data is read from the FIFO, the read pointer is moved in the read/write tag in a tail and the pointer to the data is returned. If some interrupt decides to read another data, then the next piece of data is accessed, but during the free operation, nothing is released because it is detected that the old read position does not equal the write position. When the free operation from the first task is executed, all the currently read data is marked as free. The write part of the tail tag is then changed to be equal to the read part. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

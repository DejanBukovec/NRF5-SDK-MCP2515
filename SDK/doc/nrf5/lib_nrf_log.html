<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v17.0.2: Logger module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v17.0.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lib_nrf_log.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Logger module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The logger module provides logging capability for your application. It is used by SDK modules and can be also used in the application code. Main features of this library are:</p>
<ul>
<li>Four severity levels - ERROR, WARNING, INFO, and DEBUG.</li>
<li>Formatted string (printf-like) log format.</li>
<li>Dedicated macro for dumping data.</li>
<li>Configurable global severity level.</li>
<li>Independent severity level for each module.</li>
<li>Enabling and disabling logging per module and globally.</li>
<li>Filtering on module instance level.</li>
<li>Optional timestamping with time formatting.</li>
<li>Optional coloring of the logs for different modules and different severity levels.</li>
<li>Prefixing log entries with the module name or instance name, and severity.</li>
<li>Deferring of log processing to idle stage.</li>
<li>Logging mechanism decoupled from the logger backend.</li>
<li>Multiple backends supported.</li>
<li>Several backends provided: RTT, UART, console (<a class="el" href="group__nrf__cli.html">Command Line Interface</a>), flash (see <a class="el" href="lib_nrf_log.html#nrf_log_backend_flash">Flash logger backend</a>).</li>
<li>Optional dynamic (run time) filtering on module and instance basis.</li>
<li>Storing and loading logger configuration by using <a class="el" href="group__fds.html">Flash Data Storage</a>.</li>
</ul>
<p>For API documentation of this module, see <a class="el" href="group__nrf__log.html">Logger module</a>.</p>
<h1><a class="anchor" id="nrf_log_processing"></a>
Log processing</h1>
<p>Logs can be processed using one of the following modes:</p>
<ul>
<li><a class="el" href="lib_nrf_log.html#lib_nrf_log_in_place">In-place processing</a>,</li>
<li><a class="el" href="lib_nrf_log.html#lib_nrf_log_deferred">Deferred processing</a> (default mode).</li>
</ul>
<h2><a class="anchor" id="lib_nrf_log_in_place"></a>
In-place processing</h2>
<p>When the deferred mode is switched off, the logs are processed in the place where the logger is used. This means that the pointer to a formatted string and the arguments are passed to the logger backend for processing. It is possible for the backend to buffer the logs, but the frontend part of the logging is performed once the backend processing function returns. This approach is straightforward but in many cases not optimal. It can significantly impact performance, especially when logs are used in interrupt context. The operation is not thread-safe and can lead to the corruption of the output.</p>
<h2><a class="anchor" id="lib_nrf_log_deferred"></a>
Deferred processing</h2>
<p>In the default deferred mode, whenever the logger is used, the pointer to the string and the arguments are stored in an internal buffer and the log is not processed. It is up to the user to trigger processing whenever suitable. In most cases, the processing is performed in an idle stage, when the system would normally sleep. The size of the buffer can be configured, so that it can be adjusted to the amount of log entries and the nature of idle periods in the application. In the deferred mode, logging takes considerably fewer cycles in the place where it is called (compared to in-place mode), because the processing cost is shifted to idle stage. If the buffer is too small, the logger detects it and injects an overflow marker. In such case, logging is blocked until there is room for new entries in the buffer.</p>
<p>Using the deferred mode introduces some limitations to the logging mechanism:</p>
<ul>
<li>Number of arguments in a formatted string is limited to six.</li>
<li>All arguments are treated as uint32_t. This results in the following:<ul>
<li>In certain situations (for example, smaller variables like uint8_t as arguments) the compiler gives a warning and the argument must be masked and cast to uint32_t.</li>
<li>The logger cannot handle arguments bigger than 32 bits, so they must be explicitly split up by the user into two separate entries.</li>
</ul>
</li>
<li>Since the logs are not processed directly, it is risky to pass pointers as arguments, especially to variables that do not have static addresses, for example variables allocated on the stack. By the time the log is processed, the pointer can point to invalid data. The logger provides a mechanism to overcome this issue by enforcing a string that is copied into the internal logger buffer.</li>
</ul>
<p>Given the last limitation, the following way of logging a temporary string is not recommended:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">void</span>)</div>
<div class="line">{ </div>
<div class="line">    <span class="keywordtype">char</span> string_on_stack[] = <span class="stringliteral">&quot;stack&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//WRONG! by the time the log is processed, variable content will be invalid</span></div>
<div class="line">    <a class="code" href="group__nrf__log.html#gac8d37e95648e05580513df9aaddf02c3" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_INFO</a>(<span class="stringliteral">&quot;%s&quot;</span>,string_on_stack);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Instead, use the following way of logging a temporary string:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">void</span>)</div>
<div class="line">{ </div>
<div class="line">    <span class="keywordtype">char</span> string_on_stack[] = <span class="stringliteral">&quot;stack&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">//nrf_log_push() copies the string into the logger buffer and returns address from the logger buffer</span></div>
<div class="line">    <a class="code" href="group__nrf__log.html#gac8d37e95648e05580513df9aaddf02c3" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_INFO</a>(<span class="stringliteral">&quot;%s&quot;</span>,<a class="code" href="group__nrf__log.html#ga5cd6a091973b5f459618ea53c4e47d4e" title="Macro for copying a string to internal logger buffer if logs are deferred.">NRF_LOG_PUSH</a>(string_on_stack));</div>
<div class="line">}</div>
</div><!-- fragment --><p>A dedicated buffer in the logger is used to store the strings pushed by using <a class="el" href="group__nrf__log.html#ga5cd6a091973b5f459618ea53c4e47d4e">NRF_LOG_PUSH</a>. The buffer size is configured through <a class="el" href="group__nrf__log__config.html#gaf7bd2dcbd3b311b17ea0e8258ca634cd">NRF_LOG_STR_PUSH_BUFFER_SIZE</a>. Strings are copied to the buffer without any allocation and deallocation. This means that strings can be overwritten before being processed by the backend. To avoid strings being overwritten, it is recommended to use hexdump (for example, <a class="el" href="group__nrf__log.html#ga8b3e3bc44c05013a9fbb27d08acebc9d">NRF_LOG_HEXDUMP_INFO</a>) instead of <a class="el" href="group__nrf__log.html#ga5cd6a091973b5f459618ea53c4e47d4e">NRF_LOG_PUSH</a>.</p>
<h1><a class="anchor" id="nrf_log_config"></a>
Logger configuration</h1>
<p>The following are the logger frontend configuration options:</p>
<ul>
<li><a class="el" href="group__nrf__log__config.html#gab2f7df0debb6697ce174069ce3c5f7f5">NRF_LOG_ENABLED</a> - Enable the logger. If disabled, the logger and all logger entries are not compiled.</li>
<li><a class="el" href="group__nrf__log__config.html#ga3016ad60bd2f3cd631d8371b2f98b74e">NRF_LOG_DEFAULT_LEVEL</a> - Default severity level. Available options are: ERROR (highest), WARNING, INFO, and DEBUG (lowest). This option configures the lowest severity level that can be present in the system. For example, if it is set to the INFO level, all DEBUG entries are not compiled. Every module can set a local severity level. The actual severity level that is applied for the module is the highest pick from local and global. For example, if the module severity level is set to DEBUG, but the default severity level is set to INFO, then all debug log entries in the module are not compiled.</li>
<li><a class="el" href="group__nrf__log__config.html#ga25bb8015e18e6e1105175c6486fff8a6">NRF_LOG_USES_TIMESTAMP</a> - If enabled, a timestamp is added to every log entry. The user must provide a function that returns a 32-bit timestamp value during initialization. The source of the timestamp is not important for the logger. If timestamping is enabled and this function is not provided, initialization fails with an error.</li>
<li><a class="el" href="group__nrf__log__config.html#ga0e6535f82a69e45237227a4dba92c180">NRF_LOG_USES_COLORS</a> - If enabled, every string is prefixed with an ANSI escape code with the configured color. The user can configure colors of errors (<a class="el" href="group__nrf__log__config.html#ga5ac1c03bb0f2cf9d1ebad8b7fc6e750d">NRF_LOG_ERROR_COLOR</a>) and warnings (<a class="el" href="group__nrf__log__config.html#ga40d1f488741e0c3ae4e5eaea7e3c64da">NRF_LOG_WARNING_COLOR</a>) for all modules, and the default color for info and debug logs. Colors for info and debug logs can be overriden by every module.</li>
<li><a class="el" href="group__nrf__log__config.html#ga3a13b7559dde2889c272900d38f2f41b">NRF_LOG_DEFERRED</a> - If enabled, the logs are not processed directly where they are called, but deferred to idle state. See <a class="el" href="lib_nrf_log.html#nrf_log_processing">Log processing</a>. When <a class="el" href="group__nrf__log__config.html#ga3a13b7559dde2889c272900d38f2f41b">NRF_LOG_DEFERRED</a> is enabled, the size of the internal buffer can also be configured (<a class="el" href="group__nrf__log__config.html#ga22afeab30e44d3279b09d59b4e690891">NRF_LOG_BUFSIZE</a>). Standard entries take from 4 to 32 bytes.</li>
<li><a class="el" href="group__nrf__log__config.html#gaf74fbd7ab681853e83f9b18029208e8e">NRF_LOG_ALLOW_OVERFLOW</a> - If enabled and if the internal circular buffer is full, the oldest entries are removed and new entries are stored.</li>
<li><a class="el" href="group__nrf__log__config.html#ga54de99b533b75ecce023876d24c05e98">NRF_LOG_FILTERS_ENABLED</a> - If enabled, logs can be compiled as part of a binary file, but not used unless they are enabled (which is especially useful when <a class="el" href="group__nrf__cli.html">Command Line Interface</a> is used as a backend).</li>
</ul>
<p>A module can have a section that overrides its own default logger settings. Modules can override the following configuration:</p>
<ul>
<li>Log activation in the module.</li>
<li>Independent lowest severity level.</li>
<li>Info log coloring.</li>
<li>Debug log coloring.</li>
</ul>
<h1><a class="anchor" id="nrf_log_usage"></a>
Usage</h1>
<p>Logger usage can be divided into the following tasks:</p>
<ul>
<li>Controlling the logger - initialization, reconfiguration, and triggering processing (in the deferred mode).</li>
<li>Logging.</li>
</ul>
<h2><a class="anchor" id="nrf_log_usage_control"></a>
Controlling the logger</h2>
<p>The <code>nrf_log_ctrl.h</code> file contains the API for controlling the logger. Before the logger can be used, it must be first initialized:</p>
<ul>
<li>The <a class="el" href="group__nrf__log__ctrl.html#ga7b31e89afb175ae644037fac337bcfbd">NRF_LOG_INIT()</a> macro initializes the logger. During initialization, the user must provide a pointer to the timestamp function or NULL if timestamping is disabled. If the deferred mode is used, then it is up to the user to start the processing of the buffered log entries. The <a class="el" href="group__nrf__log__ctrl.html#gaea4ee51a39f70f14ad2e3213fa497ade">NRF_LOG_PROCESS()</a> macro is used for that.</li>
<li>When <a class="el" href="group__nrf__log__ctrl.html#gaea4ee51a39f70f14ad2e3213fa497ade">NRF_LOG_PROCESS()</a> is called, the logger attempts to process a single entry and returns true if there are more entries to process, or false if the buffer is empty. When the logger is initialized, it has no backends assigned. The next step is to provide the backend by using the <a class="el" href="group__nrf__log__ctrl.html#gacdd94428c386e11a82691cc19dc0506a">nrf_log_backend_add()</a> call.</li>
<li><a class="el" href="group__nrf__log__ctrl.html#gacdd94428c386e11a82691cc19dc0506a">nrf_log_backend_add()</a> provides the interface to the logger backend. The backend must be already initialized at this point. At any time, a backend can be detached from the logger by using <a class="el" href="group__nrf__log__ctrl.html#gaf9d6b63bff41c86f96af622fa0290cd4">nrf_log_backend_remove()</a>. The logger supports up to 10 backends.</li>
</ul>
<p>Both the initialization and the addition of common backends are bundled in the nrf_log_default_backends module. The <a class="el" href="group__nrf__log__default__backends.html#gac2e95ef0e3a46df6d129589accabc9e8">NRF_LOG_DEFAULT_BACKENDS_INIT()</a> macro can be used to initialize and attach RTT or UART backend.</p>
<p>The following code snippet shows how <a class="el" href="group__nrf__log__ctrl.html#gaea4ee51a39f70f14ad2e3213fa497ade">NRF_LOG_PROCESS</a> can be incorporated into the non-preemptive scheduler. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;nrf_log_ctrl.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;nrf_log_default_backends.h&quot;</span></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    err_code = <a class="code" href="group__nrf__log__ctrl.html#ga7b31e89afb175ae644037fac337bcfbd" title="Macro for initializing the logs.">NRF_LOG_INIT</a>(timestamp_func);</div>
<div class="line">    </div>
<div class="line">    <a class="code" href="group__nrf__log__default__backends.html#gac2e95ef0e3a46df6d129589accabc9e8" title="Macro for initializing default backends.">NRF_LOG_DEFAULT_BACKENDS_INIT</a>();</div>
<div class="line"></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">while</span>(1)</div>
<div class="line">    {</div>
<div class="line">        scheduler();</div>
<div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="group__nrf__log__ctrl.html#gaea4ee51a39f70f14ad2e3213fa497ade" title="Macro for processing a single log entry from a queue of deferred logs.">NRF_LOG_PROCESS</a>())</div>
<div class="line">        { </div>
<div class="line">            <span class="comment">//sleep</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Use the <a class="el" href="group__nrf__log__ctrl.html#ga2d86a60e776a72f918d2f6cf7abc3135">NRF_LOG_FLUSH()</a> macro to ensure that all logs are processed.</p>
<p>Use the <a class="el" href="group__nrf__log__ctrl.html#ga885bb7174399e7e0a7e197ff8bf0f7b0">NRF_LOG_FINAL_FLUSH()</a> macro when logs must be flushed in the blocking mode, in case of an error, right before a reset. In such a situation, if you use the <a class="el" href="group__nrf__log__ctrl.html#ga2d86a60e776a72f918d2f6cf7abc3135">NRF_LOG_FLUSH()</a> macro, you do not receive the whole log, as the transmission will be interrupted by the reset.</p>
<h2><a class="anchor" id="nrf_log_usage_logging"></a>
Logging</h2>
<p>The <code>nrf_log.h</code> file contains the API used for logging. There are the following types of log entries:</p>
<ul>
<li>Standard logs with syntax very similar to printf - <code>NRF_LOG_&lt;SEVERITY_LEVEL&gt;()</code>.</li>
<li>Hexdump - a method for dumping the data - <code>NRF_LOG_HEXDUMP_&lt;SEVERITY_LEVEL&gt;()</code>.</li>
</ul>
<p>The following example shows the simplest way to log data in a module: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;nrf_log.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> send_func(uint8_t * p_data, uint32_t length)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__nrf__log.html#gac8d37e95648e05580513df9aaddf02c3" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_INFO</a>(<span class="stringliteral">&quot;sending data\r\n&quot;</span>);</div>
<div class="line">    <a class="code" href="group__nrf__log.html#ga543e51f0b87babd154870c494c0165f9" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_DEBUG</a>(<span class="stringliteral">&quot;%d bytes, data:\r\n&quot;</span>, length);</div>
<div class="line">    <a class="code" href="group__nrf__log.html#ga7000f8bd1f36238a99470c004cac84ea" title="Macro for logging raw bytes.">NRF_LOG_HEXDUMP_DEBUG</a>(p_data, length);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (phy_is_busy())</div>
<div class="line">    { </div>
<div class="line">        <a class="code" href="group__nrf__log.html#gaaea89bb5c09b6033729e059826711bb0" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_ERROR</a>(<span class="stringliteral">&quot;Phy is busy\r\n&quot;</span>); </div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="nrf_log_usage_logging_customization"></a>
Logging customization</h3>
<p>You can customize the logging for each module. Modules can override the severity level, the string prefix, as well as the coloring of info and warning logs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define NRF_LOG_MODULE_NAME spi</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#if SPI_CONFIG_LOG_ENABLED</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define NRF_LOG_LEVEL SPI_CONFIG_LOG_LEVEL</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define NRF_LOG_INFO_COLOR SPI_CONFIG_INFO_COLOR</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define NRF_LOG_DEBUG_COLOR SPI_CONFIG_DEBUG_COLOR</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else //SPI_CONFIG_LOG_ENABLED</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define NRF_LOG_LEVEL 0</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif //SPI_CONFIG_LOG_ENABLED</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &quot;nrf_log.h&quot;</span></div>
<div class="line"><a class="code" href="group__nrf__log.html#ga76621628447823a4d868d57f6049eef1" title="Macro for registering an independent module.">NRF_LOG_MODULE_REGISTER</a>();</div>
</div><!-- fragment --><p>If a module consists of several files, the logger customization must be repeated in every file. The only exception is <a class="el" href="group__nrf__log.html#ga76621628447823a4d868d57f6049eef1">NRF_LOG_MODULE_REGISTER()</a>, which must be called in only one file.</p>
<dl class="section note"><dt>Note</dt><dd>You can also use the following macros to produce cleaner logs, without the default prefix in the user string:<ul>
<li><a class="el" href="group__nrf__log.html#ga52fcc01ca50daa79058664f84f1111a8">NRF_LOG_RAW_INFO</a></li>
<li><a class="el" href="group__nrf__log.html#ga4a97416f7949911587dceaae3284491f">NRF_LOG_RAW_HEXDUMP_INFO</a></li>
</ul>
</dd></dl>
<p>Due to certain limitations, logging a float requires you to use the following dedicated macros: </p>
<div class="fragment"><div class="line"><a class="code" href="group__nrf__log.html#gac8d37e95648e05580513df9aaddf02c3" title="Macro for logging error messages. It takes a printf-like, formatted string with up to seven arguments...">NRF_LOG_INFO</a>(„float value:” <a class="code" href="group__nrf__log.html#ga51024b65418ae9a0e6d79fe285479b9c" title="Macro to be used in a formatted string to a pass float number to the log.">NRF_LOG_FLOAT_MARKER</a> „\r\n”, <a class="code" href="group__nrf__log.html#ga89b38475decba73ad43184a0e20168cc" title="Macro for dissecting a float number into two numbers (integer and residuum).">NRF_LOG_FLOAT</a>(val))</div>
</div><!-- fragment --><p>Because customized logging in modules relies on the redefinition of defines, including <code>nrf_log.h</code> in header files can lead to compilation failures.</p>
<h1><a class="anchor" id="nrf_log_instance_logging"></a>
Filtering logs on instance level</h1>
<p>When a module is widely used, filtering on module level is not useful. An extreme example is the module that is used by the logger system. In that case, if a different instance of the module is used elsewhere in the application, logging is impossible unless filtering is applied on instance basis.</p>
<p>The logger provides a set of macros for filtering on instance basis. The approach is similar to filtering on module basis, where for each module a specific set of variables is registered in memory sections (<a class="el" href="group__nrf__log.html#ga76621628447823a4d868d57f6049eef1">NRF_LOG_MODULE_REGISTER</a>).</p>
<h2><a class="anchor" id="nrf_log_instance_setup"></a>
Setting up instance level filtering</h2>
<p>To use this feature, the instance structure must contain a pointer to the logger structure specific to the instance, and the pointer must be initialized correctly. The logger module provides a set of macros in <code>nrf_log_instance.h</code>. If logs are disabled, the macros are empty and no additional memory is used.</p>
<p>Initialization can be encapsulated into a macro that declares an instance variable (see <a class="el" href="group__nrf__balloc.html#gaf63bcc9f522d7ad2a7d16ab288d0e012">NRF_BALLOC_DEF</a>).</p>
<p>Declaration of the instance structure: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;nrf_log_instance.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="group__nrf__log__instance.html#ga4685f1bef6eb9d2aab0466b789bd27c1" title="Macro for declaring a logger instance pointer in the module stucture.">NRF_LOG_INSTANCE_PTR_DECLARE</a>(p_log) </div>
<div class="line">} foo_t;</div>
</div><!-- fragment --><p>Instantiation macro: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FOO_DEF(_name)                                  \</span></div>
<div class="line"><span class="preprocessor">    NRF_LOG_INSTANCE_REGISTER(foo, _name, ....);        \</span></div>
<div class="line"><span class="preprocessor">    static foo_t _name = {                              \</span></div>
<div class="line"><span class="preprocessor">        NRF_LOG_INSTANCE_PTR_INIT(p_log, foo, _name)    \</span></div>
<div class="line"><span class="preprocessor">        ...                                             \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
</div><!-- fragment --><p>The <a class="el" href="group__nrf__log__instance.html#gab07651a76a02a1297143e9874c830b17">NRF_LOG_INSTANCE_REGISTER</a> macro creates a set of variables specific to the instance, such as name, current filtering level, or coloring.</p>
<h2><a class="anchor" id="nrf_log_instance_usage"></a>
Instance logging</h2>
<p>Macros for logging on instance basis are very similar to the standard logging macros with an additional parameter - pointer to the instance.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo_init(foo_t * p_foo)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//init body</span></div>
<div class="line">    <a class="code" href="group__nrf__log.html#gaf551b1c06b1f34851813e73f00331edc" title="Macro for logging error messages for a given module instance. It takes a printf-like, formatted string with up to seven arguments.">NRF_LOG_INST_INFO</a>(p_foo-&gt;p_log, <span class="stringliteral">&quot;Init&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Log messages specific to the instance are prefixed with <b>&lt;module_name&gt;.&lt;instance_name&gt;</b>, instead of the standard <b>&lt;module_name&gt;</b>.</p>
<h1><a class="anchor" id="nrf_log_performance"></a>
Performance</h1>
<p>In case of deferred logs, timing does not depend on the string length, and only slightly on the number of arguments.</p>
<p>In case of in-place processing with RTT, timing is highly dependent on the number of arguments.</p>
<p>In case of UART, the difference between deferred and in-place logging is even bigger, and highly dependent on the baud rate.</p>
<p>The following table shows performance measurements performed on nRF52.</p>
<table class="doxtable">
<tr>
<th align="left">Number of arguments </th><th align="left">In-place with RTT </th><th align="left">Deferred</th></tr>
<tr>
<td align="left">0 arguments </td><td align="left">12 us </td><td align="left">3.2 us </td></tr>
<tr>
<td align="left">6 arguments </td><td align="left">300 us </td><td align="left">4.0 us </td></tr>
</table>
<h1><a class="anchor" id="nrf_log_custom"></a>
Logger backend interface</h1>
<p>Logger backend interface is defined in <code>nrf_log_backend_interface.h</code>. Implementation of the following functions must be provided:</p>
<ul>
<li><a class="el" href="structnrf__log__backend__api__t.html#a412ca1fa92a558a962ddb48b08686e72">nrf_log_backend_api_t::put</a> - this function is called when a log entry is processed by the frontend and it passed the current backend filtering. A message is provided as an argument. The message contains unprocessed data (string pointer and arguments in case of a standard log entry).</li>
<li>panic_set - this function is called when <a class="el" href="group__nrf__log__ctrl.html#gad7bf7abb83c7378983aace256bda9a70">nrf_log_panic()</a> is called by the application. On this call, the backend must switch to blocking mode (for example, stop using interrupts) or stop processing new log entries. For details about the logger panic mode, see <a class="el" href="lib_nrf_log.html#nrf_log_panic">Panic mode</a>.</li>
<li>flush - optional flush.</li>
</ul>
<p>Messages provided with the <a class="el" href="structnrf__log__backend__api__t.html#a412ca1fa92a558a962ddb48b08686e72">nrf_log_backend_api_t::put</a> function are shared between all backends. For this reason, they must be managed by the backend implementation. <a class="el" href="group__nrf__memobj.html">Memory Object module</a> memory objects are used for storing messages.</p>
<p>When the logger frontend is processing an entry, it allocates memory for the message from the internal pool, removes the entry from the internal circular buffer, and creates the message. Then, it iterates on all attached backends and applies dynamic filtering (if enabled).</p>
<p>When the backend gets the message, it must indicate that it is in use by calling <a class="el" href="group__nrf__memobj.html#ga7712aeae5acef5407a55700acf555846">nrf_memobj_get</a>. This ensures that the message is not freed.</p>
<p><a class="el" href="group__nrf__memobj.html#ga694f0e9cedfbe41739412e9da79a0141">nrf_memobj_put</a> must be called when backend finished processing the message. The message is returned to the memory pool if it is processed by all backends.</p>
<dl class="section warning"><dt>Warning</dt><dd>In the current implementation, each and every logger backend must run on lower or equal priority as the module that is writing logs.</dd></dl>
<h2><a class="anchor" id="nrf_log_backend_flash"></a>
Flash logger backend</h2>
<p>The flash logger backend is used to store logs in non-volatile memory.</p>
<p>The backend consists of the following logical parts:</p>
<ul>
<li>flashlog - used to store log entries during application lifetime,</li>
<li>crashlog - used to dump messages logged before an error condition (<a class="el" href="group__nrf__log__ctrl.html#ga885bb7174399e7e0a7e197ff8bf0f7b0">NRF_LOG_FINAL_FLUSH</a>) and between <a class="el" href="group__nrf__log__ctrl.html#ga885bb7174399e7e0a7e197ff8bf0f7b0">NRF_LOG_FINAL_FLUSH</a> and reset.</li>
</ul>
<p>From the logger perspective, these parts are seen as independent logger backends. However, internally they share the same scheme of storing and reading log entries.</p>
<h3><a class="anchor" id="nrf_log_backend_flash_ops"></a>
Flash operations</h3>
<p>The module uses dedicated flash pages that are configured in <a class="el" href="sdk_config.html">SDK configuration header file</a>. Exact pages can be specified, or pages following the application code can be used (<a class="el" href="group__nrf__log__backend__flash__config.html#ga9faf32cb7569872da0f0951c67fb611b">NRF_LOG_BACKEND_FLASH_START_PAGE</a> set to 0). The module uses <a class="el" href="group__nrf__fstorage.html">Flash storage (fstorage)</a> to store the logs.</p>
<p>The flashlog uses the <a class="el" href="group__nrf__fstorage.html">Flash storage (fstorage)</a> asynchronous API provided during intialization, while the crashlog reinitializes <a class="el" href="group__nrf__fstorage.html">Flash storage (fstorage)</a> to work in a direct, synchronous way.</p>
<p>Log entries are serialized and stored in a dedicated area one by one until there is no more space for them. Logs are dropped if there is no space available and the area must be explicitly erased by using <a class="el" href="group__nrf__log__backend__flash.html#ga8a98eee6d90d90574a26ad0f308bbb65">nrf_log_backend_flash_erase</a> or a CLI command. On initialization, the flash area is scanned to find the last entry and the following entries are stored after it.</p>
<dl class="section note"><dt>Note</dt><dd>Strings that are used as an argument to the log message and are stored in RAM (for example, when <a class="el" href="group__nrf__log.html#ga5cd6a091973b5f459618ea53c4e47d4e">NRF_LOG_PUSH</a> is used) will be corrupted, since only the address of the string is stored.</dd></dl>
<h3><a class="anchor" id="nrf_log_backend_flash_flashlog"></a>
Flashlog operations</h3>
<p>Once the flashlog backend is initialized and enabled, it receives log messages that match the filtering configured for this backend. Flashlog attempts to write messages to flash by using asynchronous <a class="el" href="group__nrf__fstorage.html">Flash storage (fstorage)</a> API. Since access to flash is time-consuming and the area is limited, improper logger filtering configuration can lead to system overload. It is recommended to store only warning and error messages. When flashlog is used, it is recommended to increase <a class="el" href="group__nrf__log__config.html#gab4ef180f32c4543beae00be4b140f6c1">NRF_LOG_MSGPOOL_ELEMENT_COUNT</a>. This is related to the fact that flashlog keeps a log message until it is written to flash.</p>
<h3><a class="anchor" id="nrf_log_backend_flash_crashlog"></a>
Crashlog operations</h3>
<p>In a standard operation, the crashlog keeps a FIFO of the most recent log entries that match the filtering. Whenever a new log message is put into the FIFO, the oldest one is freed. Crashlog does not perform any flash operation until panic occurs (<a class="el" href="group__nrf__log__ctrl.html#ga885bb7174399e7e0a7e197ff8bf0f7b0">NRF_LOG_FINAL_FLUSH</a>). When panic occurs, <a class="el" href="group__nrf__fstorage.html">Flash storage (fstorage)</a> is reconfigured to synchronous mode and all logs from the FIFO are written to flash memory. Any log messages received in panic mode are directly written to flash. When crashlog is used, <a class="el" href="group__nrf__log__config.html#gab4ef180f32c4543beae00be4b140f6c1">NRF_LOG_MSGPOOL_ELEMENT_COUNT</a> must be increased at least by NRF_LOG_BACKEND_CRASHLOG_FIFO_SIZE, compared to the default value.</p>
<h3><a class="anchor" id="nrf_log_backend_flash_cli"></a>
Command Line Interface support</h3>
<p>The flash logger backend module provides CLI commands (<a class="el" href="group__nrf__log__backend__flash__config.html#gaf56ccf97c93823073a8ac90a2d467a61">NRF_LOG_BACKEND_FLASH_CLI_CMDS</a>) for getting the status, reading, and clearing flashlog.</p>
<h1><a class="anchor" id="nrf_log_panic"></a>
Panic mode</h1>
<p>When the system enters an unrecoverable error stage, it can no longer use interrupts and it is vital to retrieve the full log. The <a class="el" href="group__nrf__log__ctrl.html#ga885bb7174399e7e0a7e197ff8bf0f7b0">NRF_LOG_FINAL_FLUSH()</a> sends a panic notification to all attached backends through <a class="el" href="group__nrf__log__ctrl.html#gad7bf7abb83c7378983aace256bda9a70">nrf_log_panic()</a> call. When logger system switches to panic mode, the log messages are flushed. The logs that follow are processed in a blocking manner.</p>
<h1><a class="anchor" id="nrf_log_cli"></a>
Command Line Interface</h1>
<p>Logger has a set of built-in <a class="el" href="group__nrf__cli.html">Command Line Interface</a> commands that are enabled with <a class="el" href="group__nrf__log__config.html#gab3fdd3621551cb14536abc09d08fc345">NRF_LOG_CLI_CMDS</a> option. Commands can be used to control logger features and get logger status.</p>
<p>The following table lists the supported commands.</p>
<table class="doxtable">
<tr>
<th>Command name </th><th>Description </th><th>Command syntax </th></tr>
<tr>
<td>status </td><td>Prints the current severity level configuration for all modules and module instances present in the system. </td><td>- </td></tr>
<tr>
<td>list_backends </td><td>Prints all backends compiled in the system with the current status and ID. </td><td>- </td></tr>
<tr>
<td>halt </td><td>Suspends logging in the system. </td><td>- </td></tr>
<tr>
<td>go </td><td>Resumes logging in the system. </td><td>- </td></tr>
<tr>
<td>enable </td><td>Enables logging the messages for the current instance of <a class="el" href="group__nrf__cli.html">Command Line Interface</a> as a logger backend, up to the provided severity level in the listed modules. Multiple modules can be enabled in a single command. </td><td><code>log enable &lt;level&gt; &lt;module_A&gt; &lt;module_B&gt;</code><br/>
<br/>
<b>Example:</b> <code>log enable debug app_timer* queue.my_queue hardfault</code> </td></tr>
<tr>
<td>disable </td><td>Disables logging the messages for the current instance of <a class="el" href="group__nrf__cli.html">Command Line Interface</a> as a logger backend, in all modules or in the listed ones. </td><td><code>log disable &lt;optional_module_A&gt; &lt;optional_module_B&gt;</code> </td></tr>
<tr>
<td>config </td><td>Loads or stores dynamic configuration of the logger in the fds record. The configuration includes dynamic settings for all backends present in the system. </td><td><code>log config store</code>, <code>log config load</code> </td></tr>
<tr>
<td>backend </td><td>Enables control for another backend present in the system. A typical use case for this command is to configure the logger for <a class="el" href="lib_nrf_log.html#nrf_log_backend_flash">Flash logger backend</a> backend followed by <code>log config store</code> to ensure that configuration is persistent. </td><td><code>log backend &lt;backend_name&gt; &lt;any_other_log_command&gt;</code><br/>
<br/>
<b>Example:</b> <code>log backend flash_log_backend enable warning my_module</code> </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v17.0.2: Serialization PHY</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v17.0.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__ser__phy.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serialization PHY<div class="ingroups"><a class="el" href="group__ble__sdk__lib__serialization.html">Serialization</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>PHY layer for serialization.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structser__phy__evt__rx__buf__request__params__t.html">ser_phy_evt_rx_buf_request_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing parameters of event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a6586d0863748060b1f669ed34a0a0a77">SER_PHY_EVT_RX_BUF_REQUEST</a>.  <a href="structser__phy__evt__rx__buf__request__params__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structser__phy__evt__rx__pkt__received__params__t.html">ser_phy_evt_rx_pkt_received_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing parameters of event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387">SER_PHY_EVT_RX_PKT_RECEIVED</a>.  <a href="structser__phy__evt__rx__pkt__received__params__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structser__phy__evt__hw__error__params__t.html">ser_phy_evt_hw_error_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing parameters of event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061afad1fa7a81b1ed34ede87c0751125c4e">SER_PHY_EVT_HW_ERROR</a>.  <a href="structser__phy__evt__hw__error__params__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structser__phy__evt__t.html">ser_phy_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing events from a Serialization PHY module.  <a href="structser__phy__evt__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab80fabd69a044f48334eb801cfdcff09"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#gab80fabd69a044f48334eb801cfdcff09">ser_phy_events_handler_t</a> )(<a class="el" href="structser__phy__evt__t.html">ser_phy_evt_t</a> event)</td></tr>
<tr class="memdesc:gab80fabd69a044f48334eb801cfdcff09"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type of generic callback function handler to be used by all PHY module events.  <a href="#gab80fabd69a044f48334eb801cfdcff09">More...</a><br/></td></tr>
<tr class="separator:gab80fabd69a044f48334eb801cfdcff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaef62df8feedfbe682684c6f1ea704061"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#gaef62df8feedfbe682684c6f1ea704061">ser_phy_evt_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aabf6bc1f9441d6955ab6651435c4ba1f">SER_PHY_EVT_TX_PKT_SENT</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a6586d0863748060b1f669ed34a0a0a77">SER_PHY_EVT_RX_BUF_REQUEST</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387">SER_PHY_EVT_RX_PKT_RECEIVED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aea7698e3e5ecece789c5e24963180cca">SER_PHY_EVT_RX_PKT_DROPPED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a048d74d9ca16f3f7418a34967e97db5d">SER_PHY_EVT_RX_OVERFLOW_ERROR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a7d4852bdab1249f76d4f97d8a10b3e45">SER_PHY_EVT_TX_OVERREAD_ERROR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061afad1fa7a81b1ed34ede87c0751125c4e">SER_PHY_EVT_HW_ERROR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061af0005a080e3f89b9241eb098b3df2e68">SER_PHY_EVT_TYPE_MAX</a>
<br/>
 }</td></tr>
<tr class="memdesc:gaef62df8feedfbe682684c6f1ea704061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization PHY module event types.  <a href="group__ser__phy.html#gaef62df8feedfbe682684c6f1ea704061">More...</a><br/></td></tr>
<tr class="separator:gaef62df8feedfbe682684c6f1ea704061"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8c29df24b03fb3809588033581bedbbd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#ga8c29df24b03fb3809588033581bedbbd">ser_phy_open</a> (<a class="el" href="group__ser__phy.html#gab80fabd69a044f48334eb801cfdcff09">ser_phy_events_handler_t</a> events_handler)</td></tr>
<tr class="memdesc:ga8c29df24b03fb3809588033581bedbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for opening and initializing the PHY module.  <a href="#ga8c29df24b03fb3809588033581bedbbd">More...</a><br/></td></tr>
<tr class="separator:ga8c29df24b03fb3809588033581bedbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee7a0ca264b8eba6753fda021854fc4b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#gaee7a0ca264b8eba6753fda021854fc4b">ser_phy_tx_pkt_send</a> (const uint8_t *p_buffer, uint16_t num_of_bytes)</td></tr>
<tr class="memdesc:gaee7a0ca264b8eba6753fda021854fc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for transmitting a packet.  <a href="#gaee7a0ca264b8eba6753fda021854fc4b">More...</a><br/></td></tr>
<tr class="separator:gaee7a0ca264b8eba6753fda021854fc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga796b1fcdba5fbc0a38e32d20b14f21dd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#ga796b1fcdba5fbc0a38e32d20b14f21dd">ser_phy_rx_buf_set</a> (uint8_t *p_buffer)</td></tr>
<tr class="memdesc:ga796b1fcdba5fbc0a38e32d20b14f21dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting an RX buffer and enabling reception of data (the PHY flow).  <a href="#ga796b1fcdba5fbc0a38e32d20b14f21dd">More...</a><br/></td></tr>
<tr class="separator:ga796b1fcdba5fbc0a38e32d20b14f21dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a80424c3b4fdadc38f88360fc669ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#ga98a80424c3b4fdadc38f88360fc669ef">ser_phy_close</a> (void)</td></tr>
<tr class="memdesc:ga98a80424c3b4fdadc38f88360fc669ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for closing the PHY module.  <a href="#ga98a80424c3b4fdadc38f88360fc669ef">More...</a><br/></td></tr>
<tr class="separator:ga98a80424c3b4fdadc38f88360fc669ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c85bfafdff51bc862cc5c1bbec0242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#gaf2c85bfafdff51bc862cc5c1bbec0242">ser_phy_interrupts_enable</a> (void)</td></tr>
<tr class="memdesc:gaf2c85bfafdff51bc862cc5c1bbec0242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the PHY module interrupts.  <a href="#gaf2c85bfafdff51bc862cc5c1bbec0242">More...</a><br/></td></tr>
<tr class="separator:gaf2c85bfafdff51bc862cc5c1bbec0242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb87bb79dd3e18e41b06748a5252995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ser__phy.html#ga9fb87bb79dd3e18e41b06748a5252995">ser_phy_interrupts_disable</a> (void)</td></tr>
<tr class="memdesc:ga9fb87bb79dd3e18e41b06748a5252995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the PHY module interrupts.  <a href="#ga9fb87bb79dd3e18e41b06748a5252995">More...</a><br/></td></tr>
<tr class="separator:ga9fb87bb79dd3e18e41b06748a5252995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>PHY layer for serialization. </p>
<p>The <a class="el" href="group__ser__phy.html">Serialization PHY</a> library declares functions and definitions of data structures and identifiers (typedef enum) that are used as API of the serialization PHY layer.</p>
<dl class="section user"><dt>Rationale</dt><dd>Each specific PHY layer (SPI, I2C, UART, low power UART etc.) should provide the same API. This allows the layer above (the HAL Transport layer), which is responsible for controlling the PHY layer, memory management, CRC, retransmission etc., to be hardware independent.</dd></dl>
<dl class="section user"><dt>Interlayer communication and control</dt><dd>The PHY layer is controlled by the HAL transport layer by calling functions declared in the <a class="el" href="group__ser__phy.html">Serialization PHY</a> library.</dd></dl>
<dl class="section user"><dt></dt><dd>The PHY layer communicates events to the HAL transport layer by calling a callback function. A handler to this function is passed in the <a class="el" href="group__ser__phy.html#ga8c29df24b03fb3809588033581bedbbd">ser_phy_open</a> function. This callback function should be called with a parameter of type <a class="el" href="structser__phy__evt__t.html">ser_phy_evt_t</a>, filled accordingly to an event to be passed. Types of supported events are defined in <a class="el" href="group__ser__phy.html#gaef62df8feedfbe682684c6f1ea704061">ser_phy_evt_type_t</a>.</dd></dl>
<dl class="section user"><dt></dt><dd>For example, to pass an event indicating that an RX packet has been successfully received, first a struct of type <a class="el" href="structser__phy__evt__t.html">ser_phy_evt_t</a> must be filled: <div class="fragment"><div class="line"><a class="code" href="structser__phy__evt__t.html" title="A struct containing events from a Serialization PHY module.">ser_phy_evt_t</a> phy_evt;</div>
<div class="line">phy_evt.<a class="code" href="structser__phy__evt__t.html#ae588b73e9d0730410d87a4d1c246ff74">evt_type</a> = <a class="code" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387">SER_PHY_EVT_RX_PKT_RECEIVED</a>;</div>
<div class="line">phy_evt.evt_params.<a class="code" href="structser__phy__evt__t.html#a025d488d61f3d284d37bea8b37ec2284">rx_pkt_received</a>.<a class="code" href="structser__phy__evt__rx__pkt__received__params__t.html#a99d0194bb9ca302f67969e1ed923cb1b">p_buffer</a> = (pointer to the RX buffer);</div>
<div class="line">phy_evt.evt_params.<a class="code" href="structser__phy__evt__t.html#a025d488d61f3d284d37bea8b37ec2284">rx_pkt_received</a>.<a class="code" href="structser__phy__evt__rx__pkt__received__params__t.html#aeb3880102935019faab8a8d2b9e51af7">num_of_bytes</a> = (number of received bytes);</div>
</div><!-- fragment --> Then, the callback function must be called: <div class="fragment"><div class="line">events_handler(phy_evt);</div>
</div><!-- fragment --> All functions declared in the <a class="el" href="group__ser__phy.html">Serialization PHY</a> file (ser_phy.h) must be implemented. Some events specified in <a class="el" href="group__ser__phy.html#gaef62df8feedfbe682684c6f1ea704061">ser_phy_evt_type_t</a> are optional to implement.</dd></dl>
<dl class="section user"><dt>Transmitting a packet</dt><dd>Each PHY layer is responsible for adding the PHY header to a packet to be sent. This header consists of a 16-bit field that carries the packet length (the uint16_encode function defined in app_util.h should be used to ensure endianness independence). A pointer to a packet to be sent and length of the packet are parameters of the <a class="el" href="group__ser__phy.html#gaee7a0ca264b8eba6753fda021854fc4b">ser_phy_tx_pkt_send</a> function. When a packet has been transmitted, an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aabf6bc1f9441d6955ab6651435c4ba1f">SER_PHY_EVT_TX_PKT_SENT</a> should be emitted.</dd></dl>
<div class="image">
<img src="ser_phy_transport_tx.svg" alt="ser_phy_transport_tx.svg"/>
<div class="caption">
TX - interlayer communication</div></div>
 <dl class="section user"><dt>Receiving a packet</dt><dd>The PHY layer should be able to store only the PHY header (16-bit field carrying the packet length). After the PHY header has been received, the transmission is stopped and the PHY layer must send a request to the HAL transport layer for memory to store the packet - an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a6586d0863748060b1f669ed34a0a0a77">SER_PHY_EVT_RX_BUF_REQUEST</a> with event parameters defined in <a class="el" href="structser__phy__evt__rx__buf__request__params__t.html">ser_phy_evt_rx_buf_request_params_t</a> (the uint16_decode function defined in app_util.h should be used for header decoding to ensure endianness independence). The transmission should be resumed when the <a class="el" href="group__ser__phy.html#ga796b1fcdba5fbc0a38e32d20b14f21dd">ser_phy_rx_buf_set</a> function has been called.</dd></dl>
<dl class="section user"><dt></dt><dd>When the <a class="el" href="group__ser__phy.html#ga796b1fcdba5fbc0a38e32d20b14f21dd">ser_phy_rx_buf_set</a> function parameter equals NULL, there is not enough memory to store the packet. However, the packet will be received to a dummy location to ensure continuous communication. After receiving has finished, an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aea7698e3e5ecece789c5e24963180cca">SER_PHY_EVT_RX_PKT_DROPPED</a> is generated.</dd></dl>
<div class="image">
<img src="ser_phy_transport_rx_dropped.svg" alt="ser_phy_transport_rx_dropped.svg"/>
<div class="caption">
RX dropping - interlayer communication</div></div>
 <dl class="section user"><dt></dt><dd>When the <a class="el" href="group__ser__phy.html#ga796b1fcdba5fbc0a38e32d20b14f21dd">ser_phy_rx_buf_set</a> function parameter is different than NULL, the packet is received to a buffer pointed to by it. After receiving has finished, an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387">SER_PHY_EVT_RX_PKT_RECEIVED</a> is generated with event parameters defined in <a class="el" href="structser__phy__evt__rx__pkt__received__params__t.html">ser_phy_evt_rx_pkt_received_params_t</a>.</dd></dl>
<div class="image">
<img src="ser_phy_transport_rx_received.svg" alt="ser_phy_transport_rx_received.svg"/>
<div class="caption">
RX - interlayer communication</div></div>
 <dl class="section user"><dt>PHY layer errors</dt><dd>PHY layer errors can be signaled by an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a048d74d9ca16f3f7418a34967e97db5d">SER_PHY_EVT_RX_OVERFLOW_ERROR</a> or <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a7d4852bdab1249f76d4f97d8a10b3e45">SER_PHY_EVT_TX_OVERREAD_ERROR</a> or <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061afad1fa7a81b1ed34ede87c0751125c4e">SER_PHY_EVT_HW_ERROR</a> with event parameters defined in <a class="el" href="structser__phy__evt__hw__error__params__t.html">ser_phy_evt_hw_error_params_t</a>.</dd></dl>
<dl class="section user"><dt>Available PHY layers</dt><dd>The following PHY layers are available:<ul>
<li><a class="el" href="ser_phy_spi_page.html">SPI RAW protocol</a></li>
<li><a class="el" href="ser_phy_spi_5_w_page.html">SPI_5W RAW protocol</a></li>
<li><a class="el" href="ser_phy_uart_page.html">UART RAW protocol</a></li>
<li><a class="el" href="ser_phy_uart_hci_page.html">UART HCI protocol</a> </li>
</ul>
</dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gab80fabd69a044f48334eb801cfdcff09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ser_phy_events_handler_t)(<a class="el" href="structser__phy__evt__t.html">ser_phy_evt_t</a> event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type of generic callback function handler to be used by all PHY module events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Serialization PHY module event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaef62df8feedfbe682684c6f1ea704061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ser__phy.html#gaef62df8feedfbe682684c6f1ea704061">ser_phy_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialization PHY module event types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061aabf6bc1f9441d6955ab6651435c4ba1f"></a>SER_PHY_EVT_TX_PKT_SENT</em>&nbsp;</td><td class="fielddoc">
<p>Obligatory to implement. An event indicating that a TX packet has been transmitted. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061a6586d0863748060b1f669ed34a0a0a77"></a>SER_PHY_EVT_RX_BUF_REQUEST</em>&nbsp;</td><td class="fielddoc">
<p>Obligatory to implement. An event indicating that the PHY layer needs a buffer for an RX packet. The PHY flow should be blocked until the <a class="el" href="group__ser__phy.html#ga796b1fcdba5fbc0a38e32d20b14f21dd">ser_phy_rx_buf_set</a> function is called. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387"></a>SER_PHY_EVT_RX_PKT_RECEIVED</em>&nbsp;</td><td class="fielddoc">
<p>Obligatory to implement. An event indicating that an RX packet has been successfully received. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061aea7698e3e5ecece789c5e24963180cca"></a>SER_PHY_EVT_RX_PKT_DROPPED</em>&nbsp;</td><td class="fielddoc">
<p>Obligatory to implement. An event indicating that the RX packet receiving has been finished but the packet was discarded because it was longer than available the buffer. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061a048d74d9ca16f3f7418a34967e97db5d"></a>SER_PHY_EVT_RX_OVERFLOW_ERROR</em>&nbsp;</td><td class="fielddoc">
<p>Optional to implement. An event indicating that more information has been transmitted than the PHY module could handle. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061a7d4852bdab1249f76d4f97d8a10b3e45"></a>SER_PHY_EVT_TX_OVERREAD_ERROR</em>&nbsp;</td><td class="fielddoc">
<p>Optional to implement. An event indicating that the PHY module was forced to transmit more information than possessed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061afad1fa7a81b1ed34ede87c0751125c4e"></a>SER_PHY_EVT_HW_ERROR</em>&nbsp;</td><td class="fielddoc">
<p>Optional to implement. An event indicating a hardware error in the PHY module. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaef62df8feedfbe682684c6f1ea704061af0005a080e3f89b9241eb098b3df2e68"></a>SER_PHY_EVT_TYPE_MAX</em>&nbsp;</td><td class="fielddoc">
<p>Enumeration upper bound. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga98a80424c3b4fdadc38f88360fc669ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ser_phy_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for closing the PHY module. </p>
<dl class="section note"><dt>Note</dt><dd>The function disables hardware, resets internal module states, and unregisters the events callback function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fb87bb79dd3e18e41b06748a5252995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ser_phy_interrupts_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the PHY module interrupts. </p>
<dl class="section note"><dt>Note</dt><dd>The function disables all interrupts that are used by the PHY module (and only those). </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2c85bfafdff51bc862cc5c1bbec0242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ser_phy_interrupts_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the PHY module interrupts. </p>
<dl class="section note"><dt>Note</dt><dd>The function enables all interrupts that are used by the PHY module (and only those). </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c29df24b03fb3809588033581bedbbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ser_phy_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ser__phy.html#gab80fabd69a044f48334eb801cfdcff09">ser_phy_events_handler_t</a>&#160;</td>
          <td class="paramname"><em>events_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for opening and initializing the PHY module. </p>
<dl class="section note"><dt>Note</dt><dd>The function initializes hardware and internal module states, and registers callback function to be used by all PHY module events.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the function has been already called, the function <a class="el" href="group__ser__phy.html#ga98a80424c3b4fdadc38f88360fc669ef">ser_phy_close</a> has to be called before ser_phy_open can be called again.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events_handler</td><td>Generic callback function handler to be used by all PHY module events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>Operation failure. The function has been already called. To call it again, the function <a class="el" href="group__ser__phy.html#ga98a80424c3b4fdadc38f88360fc669ef">ser_phy_close</a> has to be called first. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>Operation failure. NULL pointer supplied. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>Operation failure. Hardware initialization parameters are not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga796b1fcdba5fbc0a38e32d20b14f21dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ser_phy_rx_buf_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting an RX buffer and enabling reception of data (the PHY flow). </p>
<dl class="section note"><dt>Note</dt><dd>The function has to be called as a response to an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061a6586d0863748060b1f669ed34a0a0a77">SER_PHY_EVT_RX_BUF_REQUEST</a>. The function sets an RX buffer and enables reception of data (enables the PHY flow). Size of a buffer pointed by the p_buffer parameter should be at least equal to the num_of_bytes parameter passed within the event (<a class="el" href="structser__phy__evt__rx__buf__request__params__t.html">ser_phy_evt_rx_buf_request_params_t</a>), or p_buffer should be equal to NULL if there is not enough memory. When p_buffer is different from NULL and num_of_bytes octets have been received, an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061ab7c2a10cee66d30f6f2502376857b387">SER_PHY_EVT_RX_PKT_RECEIVED</a> is generated (<a class="el" href="structser__phy__evt__rx__pkt__received__params__t.html">ser_phy_evt_rx_pkt_received_params_t</a>). When p_buffer is equal to NULL, data is received to dummy location to ensure continuous communication. Then, if num_of_bytes octets have been received, an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aea7698e3e5ecece789c5e24963180cca">SER_PHY_EVT_RX_PKT_DROPPED</a> is generated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_buffer</td><td>Pointer to an RX buffer in which to receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>Operation failure. A buffer was set without request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee7a0ca264b8eba6753fda021854fc4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ser_phy_tx_pkt_send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>p_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_of_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for transmitting a packet. </p>
<dl class="section note"><dt>Note</dt><dd>The function adds a packet pointed by p_buffer parameter to a transmission queue and schedules generation of an event of type <a class="el" href="group__ser__phy.html#ggaef62df8feedfbe682684c6f1ea704061aabf6bc1f9441d6955ab6651435c4ba1f">SER_PHY_EVT_TX_PKT_SENT</a> upon transmission completion.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_buffer</td><td>Pointer to a buffer to transmit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_bytes</td><td>Number of octets to transmit. Must be more than 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. Packet was added to the transmission queue and event will be send upon transmission completion. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>Operation failure. NULL pointer supplied. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>Operation failure. The num_of_bytes parameter equal to 0. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Operation failure. Transmitting of a packet in progress. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

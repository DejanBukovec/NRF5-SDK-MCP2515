<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v17.0.2: PWM driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v17.0.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nrfx__pwm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PWM driver<div class="ingroups"><a class="el" href="group__nrf__pwm.html">PWM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Pulse Width Modulation (PWM) peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrfx__pwm__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm__config.html">PWM peripheral driver configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver instance data structure.  <a href="structnrfx__pwm__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver configuration structure.  <a href="structnrfx__pwm__config__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga248fea7bfb810bed3145b9927b7ab679"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga248fea7bfb810bed3145b9927b7ab679">NRFX_PWM_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:ga248fea7bfb810bed3145b9927b7ab679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating a PWM driver instance.  <a href="#ga248fea7bfb810bed3145b9927b7ab679">More...</a><br/></td></tr>
<tr class="separator:ga248fea7bfb810bed3145b9927b7ab679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8d0f4652322f07b3225d8be97984bfdc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga8d0f4652322f07b3225d8be97984bfdc">NRFX_PWM_PIN_NOT_USED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8d0f4652322f07b3225d8be97984bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be provided instead of a pin number for any channel to specify that its output is not used and therefore does not need to be connected to a pin. <br/></td></tr>
<tr class="separator:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga730fb957fc2eec7d963a44f6631bbb63"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga730fb957fc2eec7d963a44f6631bbb63">NRFX_PWM_PIN_INVERTED</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ga730fb957fc2eec7d963a44f6631bbb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be added to a pin number to invert its polarity (set idle state = 1). <br/></td></tr>
<tr class="separator:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad7090e8b64090dcc4d3b5c5d9283452e">NRFX_PWM_DEFAULT_CONFIG</a></td></tr>
<tr class="memdesc:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver default configuration.  <a href="#gad7090e8b64090dcc4d3b5c5d9283452e">More...</a><br/></td></tr>
<tr class="separator:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga106484a1e96d57ab61dcfe52bd796661"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga106484a1e96d57ab61dcfe52bd796661"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga106484a1e96d57ab61dcfe52bd796661">nrfx_pwm_handler_t</a> )(<a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> event_type)</td></tr>
<tr class="memdesc:ga106484a1e96d57ab61dcfe52bd796661"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event handler type. <br/></td></tr>
<tr class="separator:ga106484a1e96d57ab61dcfe52bd796661"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a> = 0x01, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad">NRFX_PWM_FLAG_LOOP</a> = 0x02, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> = 0x04, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> = 0x08, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465">NRFX_PWM_FLAG_NO_EVT_FINISHED</a> = 0x10, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> = 0x80
<br/>
 }</td></tr>
<tr class="memdesc:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM flags that provide additional playback options.  <a href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">More...</a><br/></td></tr>
<tr class="separator:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd252a13f482085e89e23516b8a422a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> { <br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f">NRFX_PWM_EVT_FINISHED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a>, 
<br/>
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga3bd252a13f482085e89e23516b8a422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event type.  <a href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">More...</a><br/></td></tr>
<tr class="separator:ga3bd252a13f482085e89e23516b8a422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf06bb9053293005bc91217e5a1791261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gaf06bb9053293005bc91217e5a1791261">nrfx_pwm_init</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *p_config, <a class="el" href="group__nrfx__pwm.html#ga106484a1e96d57ab61dcfe52bd796661">nrfx_pwm_handler_t</a> handler)</td></tr>
<tr class="memdesc:gaf06bb9053293005bc91217e5a1791261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the PWM driver.  <a href="#gaf06bb9053293005bc91217e5a1791261">More...</a><br/></td></tr>
<tr class="separator:gaf06bb9053293005bc91217e5a1791261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga8d39f32db25a3bd9c61eeb9f719be6b3">nrfx_pwm_uninit</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the PWM driver.  <a href="#ga8d39f32db25a3bd9c61eeb9f719be6b3">More...</a><br/></td></tr>
<tr class="separator:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gafbdadeeba36d9f70239f9cf08f4c9ff4">nrfx_pwm_simple_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a single sequence playback.  <a href="#gafbdadeeba36d9f70239f9cf08f4c9ff4">More...</a><br/></td></tr>
<tr class="separator:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga9ace01a636ac528b3c233e0ae661e5e7">nrfx_pwm_complex_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_0, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_1, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a two-sequence playback.  <a href="#ga9ace01a636ac528b3c233e0ae661e5e7">More...</a><br/></td></tr>
<tr class="separator:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga2428ab5f507f0e84f4f7c535cc973fa1">nrfx_pwm_step</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for advancing the active sequence.  <a href="#ga2428ab5f507f0e84f4f7c535cc973fa1">More...</a><br/></td></tr>
<tr class="separator:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d372f2f710abacd79ec5aefc358c8af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga7d372f2f710abacd79ec5aefc358c8af">nrfx_pwm_stop</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, bool wait_until_stopped)</td></tr>
<tr class="memdesc:ga7d372f2f710abacd79ec5aefc358c8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for stopping the sequence playback.  <a href="#ga7d372f2f710abacd79ec5aefc358c8af">More...</a><br/></td></tr>
<tr class="separator:ga7d372f2f710abacd79ec5aefc358c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga5acf4c1265c548ce1f891b0f80e75ec7">nrfx_pwm_is_stopped</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking the status of the PWM peripheral.  <a href="#ga5acf4c1265c548ce1f891b0f80e75ec7">More...</a><br/></td></tr>
<tr class="separator:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74da7834ea60b27b278662ede880384"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gab74da7834ea60b27b278662ede880384">nrfx_pwm_sequence_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence)</td></tr>
<tr class="memdesc:gab74da7834ea60b27b278662ede880384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the sequence data during playback.  <a href="#gab74da7834ea60b27b278662ede880384">More...</a><br/></td></tr>
<tr class="separator:gab74da7834ea60b27b278662ede880384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd54088a2789e7751871a1745b3207ec"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gabd54088a2789e7751871a1745b3207ec">nrfx_pwm_sequence_values_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, <a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a> values)</td></tr>
<tr class="memdesc:gabd54088a2789e7751871a1745b3207ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the pointer to the duty cycle values in the specified sequence during playback.  <a href="#gabd54088a2789e7751871a1745b3207ec">More...</a><br/></td></tr>
<tr class="separator:gabd54088a2789e7751871a1745b3207ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad4f0ba95dcabb3e78197e10f5b1666dc">nrfx_pwm_sequence_length_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint16_t length)</td></tr>
<tr class="memdesc:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of duty cycle values in the specified sequence during playback.  <a href="#gad4f0ba95dcabb3e78197e10f5b1666dc">More...</a><br/></td></tr>
<tr class="separator:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13477b80691014995ef33cdc1b97a0a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gac13477b80691014995ef33cdc1b97a0a">nrfx_pwm_sequence_repeats_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint32_t repeats)</td></tr>
<tr class="memdesc:gac13477b80691014995ef33cdc1b97a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of repeats for duty cycle values in the specified sequence during playback.  <a href="#gac13477b80691014995ef33cdc1b97a0a">More...</a><br/></td></tr>
<tr class="separator:gac13477b80691014995ef33cdc1b97a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga13f7c4b37a0b4f83f7251f4e096cdf42">nrfx_pwm_sequence_end_delay_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint32_t end_delay)</td></tr>
<tr class="memdesc:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the additional delay after the specified sequence during playback.  <a href="#ga13f7c4b37a0b4f83f7251f4e096cdf42">More...</a><br/></td></tr>
<tr class="separator:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga0d26ec5e3a8d62940cbbe656e15bfa03">nrfx_pwm_task_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a> task)</td></tr>
<tr class="memdesc:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM task that can be used in PPI module.  <a href="#ga0d26ec5e3a8d62940cbbe656e15bfa03">More...</a><br/></td></tr>
<tr class="separator:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a61720521d98af91339130a23ec658"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gae0a61720521d98af91339130a23ec658">nrfx_pwm_event_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a> event)</td></tr>
<tr class="memdesc:gae0a61720521d98af91339130a23ec658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM event that can be used in PPI module.  <a href="#gae0a61720521d98af91339130a23ec658">More...</a><br/></td></tr>
<tr class="separator:gae0a61720521d98af91339130a23ec658"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pulse Width Modulation (PWM) peripheral driver. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gad7090e8b64090dcc4d3b5c5d9283452e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_DEFAULT_CONFIG</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                          \</div>
<div class="line">    .output_pins  = { <a class="code" href="group__nrfx__pwm__config.html#gae47e25a4270f19fad1db05d74789cc99" title="Out0 pin.">NRFX_PWM_DEFAULT_CONFIG_OUT0_PIN</a>,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT1_PIN,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT2_PIN,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT3_PIN },                  \</div>
<div class="line">    .irq_priority = <a class="code" href="group__nrfx__pwm__config.html#ga097ff5d073d1266dde45fbe2b0dbddc9" title="Interrupt priority.">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a>,                  \</div>
<div class="line">    .base_clock   = (<a class="code" href="group__nrf__pwm__hal.html#ga8479da20e14394fb2388b1be3b879670" title="PWM base clock frequencies.">nrf_pwm_clk_t</a>)<a class="code" href="group__nrfx__pwm__config.html#ga6cad4e008f74d9a464d86b5b32422005" title="Base clock.">NRFX_PWM_DEFAULT_CONFIG_BASE_CLOCK</a>,     \</div>
<div class="line">    .count_mode   = (<a class="code" href="group__nrf__pwm__hal.html#ga1f29b190ff13c52895d249e07ebe92cb" title="PWM modes of operation.">nrf_pwm_mode_t</a>)<a class="code" href="group__nrfx__pwm__config.html#gab0e12dfd2269daf12ee42af8d79539fe" title="Count mode.">NRFX_PWM_DEFAULT_CONFIG_COUNT_MODE</a>,    \</div>
<div class="line">    .top_value    = <a class="code" href="group__nrfx__pwm__config.html#ga34a78c0f3fbb073b2e5b399b1e2a66c6" title="Top value.">NRFX_PWM_DEFAULT_CONFIG_TOP_VALUE</a>,                     \</div>
<div class="line">    .load_mode    = (<a class="code" href="group__nrf__pwm__hal.html#ga453888e5feb46774da27499ca1eeafd2" title="PWM decoder load modes.">nrf_pwm_dec_load_t</a>)<a class="code" href="group__nrfx__pwm__config.html#ga48733405a8c474d7cf5abf7ba4eef89f" title="Load mode.">NRFX_PWM_DEFAULT_CONFIG_LOAD_MODE</a>, \</div>
<div class="line">    .step_mode    = (<a class="code" href="group__nrf__pwm__hal.html#gae25a7e03c383934d33cda8a049b7dde4" title="PWM decoder next step modes.">nrf_pwm_dec_step_t</a>)<a class="code" href="group__nrfx__pwm__config.html#gae20e4c1fd83af3d09b0c5c5a065b769b" title="Step mode.">NRFX_PWM_DEFAULT_CONFIG_STEP_MODE</a>, \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>PWM driver default configuration. </p>

</div>
</div>
<a class="anchor" id="ga248fea7bfb810bed3145b9927b7ab679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                           \</div>
<div class="line">    .p_registers  = <a class="code" href="group__nrfx__common.html#ga9fced903f4d0fc450e63d40426050236" title="Macro for concatenating two tokens in macro expansion.">NRFX_CONCAT_2</a>(NRF_PWM, <span class="keywordtype">id</span>),             \</div>
<div class="line">    .drv_inst_idx = <a class="code" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4" title="Macro for concatenating three tokens in macro expansion.">NRFX_CONCAT_3</a>(NRFX_PWM, <span class="keywordtype">id</span>, _INST_IDX), \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro for creating a PWM driver instance. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga3bd252a13f482085e89e23516b8a422a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM driver event type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f"></a>NRFX_PWM_EVT_FINISHED</em>&nbsp;</td><td class="fielddoc">
<p>Sequence playback finished. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30"></a>NRFX_PWM_EVT_END_SEQ0</em>&nbsp;</td><td class="fielddoc">
<p>End of sequence 0 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957"></a>NRFX_PWM_EVT_END_SEQ1</em>&nbsp;</td><td class="fielddoc">
<p>End of sequence 1 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a"></a>NRFX_PWM_EVT_STOPPED</em>&nbsp;</td><td class="fielddoc">
<p>The PWM peripheral has been stopped. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga68ffb6414b8b5e07ddb4e14431b2bd1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM flags that provide additional playback options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18"></a>NRFX_PWM_FLAG_STOP</em>&nbsp;</td><td class="fielddoc">
<p>When the requested playback is finished, the peripheral will be stopped. </p>
<dl class="section note"><dt>Note</dt><dd>The STOP task is triggered when the last value of the final sequence is loaded from RAM, and the peripheral stops at the end of the current PWM period. For sequences with configured repeating of duty cycle values, this might result in less than the requested number of repeats of the last value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad"></a>NRFX_PWM_FLAG_LOOP</em>&nbsp;</td><td class="fielddoc">
<p>When the requested playback is finished, it will be started from the beginning. This flag is ignored if used together with <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The playback restart is done via a shortcut configured in the PWM peripheral. This shortcut triggers the proper starting task when the final value of previous playback is read from RAM and applied to the pulse generator counter. When this mechanism is used together with the <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode, the playback restart will occur right after switching to the final value (this final value will be played only once). </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ0</em>&nbsp;</td><td class="fielddoc">
<p>The event handler is to be called when the last value from sequence 0 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ1</em>&nbsp;</td><td class="fielddoc">
<p>The event handler is to be called when the last value from sequence 1 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465"></a>NRFX_PWM_FLAG_NO_EVT_FINISHED</em>&nbsp;</td><td class="fielddoc">
<p>The playback finished event (enabled by default) is to be suppressed. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec"></a>NRFX_PWM_FLAG_START_VIA_TASK</em>&nbsp;</td><td class="fielddoc">
<p>The playback must not be started directly by the called function. Instead, the function must only prepare it and return the address of the task to be triggered to start the playback. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9ace01a636ac528b3c233e0ae661e5e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_complex_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a two-sequence playback. </p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (using PPI for instance). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_0</td><td>First sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_1</td><td>Second sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="gae0a61720521d98af91339130a23ec658"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t nrfx_pwm_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM event that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Requested event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf06bb9053293005bc91217e5a1791261"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_pwm_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__pwm.html#ga106484a1e96d57ab61dcfe52bd796661">nrfx_pwm_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the PWM driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with the initial configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler provided by the user. If NULL is passed instead, event notifications are not done and PWM interrupts are disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>Initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>The driver was already initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5acf4c1265c548ce1f891b0f80e75ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_is_stopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking the status of the PWM peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13f7c4b37a0b4f83f7251f4e096cdf42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_sequence_end_delay_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the additional delay after the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_delay</td><td>New end delay value (in PWM periods). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad4f0ba95dcabb3e78197e10f5b1666dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_sequence_length_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>New number of the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac13477b80691014995ef33cdc1b97a0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_sequence_repeats_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>repeats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of repeats for duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repeats</td><td>New number of repeats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab74da7834ea60b27b278662ede880384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_sequence_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the sequence data during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Pointer to the new sequence definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabd54088a2789e7751871a1745b3207ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_sequence_values_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the pointer to the duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>New pointer to the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafbdadeeba36d9f70239f9cf08f4c9ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_simple_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a single sequence playback. </p>
<p>To take advantage of the looping mechanism in the PWM peripheral, both sequences must be used (single sequence can be played back only once by the peripheral). Therefore, the provided sequence is internally set and played back as both sequence 0 and sequence 1. Consequently, if the end of sequence notifications are required, events for both sequences must be used (that is, both the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> flag and the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> flag must be specified, and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a> event and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a> event must be handled in the same way).</p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (for example, by using PPI). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on the stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2428ab5f507f0e84f4f7c535cc973fa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void nrfx_pwm_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for advancing the active sequence. </p>
<p>This function only applies to <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7d372f2f710abacd79ec5aefc358c8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_stopped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for stopping the sequence playback. </p>
<p>The playback is stopped at the end of the current PWM period. This means that if the active sequence is configured to repeat each duty cycle value for a certain number of PWM periods, the last played value might appear on the output less times than requested.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be instructed to wait until the playback is stopped (by setting <code>wait_until_stopped</code> to true). Depending on the length of the PMW period, this might take a significant amount of time. Alternatively, the <a class="el" href="group__nrfx__pwm.html#ga5acf4c1265c548ce1f891b0f80e75ec7">nrfx_pwm_is_stopped</a> function can be used to poll the status, or the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a> event can be used to get the notification when the playback is stopped, provided the event handler is defined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_until_stopped</td><td>If true, the function will not return until the playback is stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>The PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0d26ec5e3a8d62940cbbe656e15bfa03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t nrfx_pwm_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM task that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Requested task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d39f32db25a3bd9c61eeb9f719be6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the PWM driver. </p>
<p>If any sequence playback is in progress, it is stopped immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>

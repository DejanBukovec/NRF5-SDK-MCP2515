<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>nRF5 SDK v17.0.2: USB Device high level library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet_offline.css" rel="stylesheet" type="text/css"/>
<link href="nordic.css" rel="stylesheet" type="text/css" />
<link rel="Shortcut icon" href="./favicon.ico" type="image/x-icon" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%" class="blank">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Nordic Semiconductor" src="nordic_small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">nRF5 SDK
   &#160;<span id="projectnumber">v17.0.2</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<table cellspacing="0" cellpadding="0" class="blank">
<tr>
<td class="doclinkintro">Choose documentation:</td>
<td class="doclinks" id="nrf5"><a href="../nrf5/index.html">nRF5 SDK</a></td>
<td class="doclinks" id="s112"><a href="../s112/index.html">S112 SoftDevice API</a></td>
<td class="doclinks" id="s113"><a href="../s113/index.html">S113 SoftDevice API</a></td>
<td class="doclinks" id="s122"><a href="../s122/index.html">S122 SoftDevice API</a></td>
<td class="doclinks" id="s132"><a href="../s132/index.html">S132 SoftDevice API</a></td>
<td class="doclinks" id="s140"><a href="../s140/index.html">S140 SoftDevice API</a></td>
<td class="doclinks" id="s212"><a href="../s212/index.html">S212 SoftDevice API</a></td>
<td class="doclinks" id="s312"><a href="../s312/index.html">S312 SoftDevice API</a></td>
<td class="doclinks" id="s332"><a href="../s332/index.html">S332 SoftDevice API</a></td>
<td class="doclinks" id="s340"><a href="../s340/index.html">S340 SoftDevice API</a></td>
</tr>
</table>
<script>
var url=window.location.href.split("/").reverse()[1];
var validLinks= ["nrf5","s112","s113","s122","s132","s140","s212","s312","s332","s340"];
var index;
for (index = 0; index < validLinks.length; ++index) {
   if ( url.indexOf(validLinks[index]) !== -1 ) {
      document.getElementById(validLinks[index]).setAttribute('class', 'doclinks docselected');
   };
};
</script>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__app__usbd.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Device high level library<div class="ingroups"><a class="el" href="group__app__common.html">SDK common libraries</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><span class="whichnRF nRF52840">nRF52840 only:</span> Module for easy support for any USB device configuration.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__app__usbd__class__base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__class__base.html">USBD Class Base module</a></td></tr>
<tr class="memdesc:group__app__usbd__class__base"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> The base for any class instance is defined in this module. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__core"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__core.html">USB Device high level library core module</a></td></tr>
<tr class="memdesc:group__app__usbd__core"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Core module that manages current USB state and process device requests. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__descriptor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__descriptor.html">USB standard descriptors</a></td></tr>
<tr class="memdesc:group__app__usbd__descriptor"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types definitions used for standard descriptors. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__request"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__request.html">USB standard requests</a></td></tr>
<tr class="memdesc:group__app__usbd__request"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types definitions used for standard requests processing. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__serial__num"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__serial__num.html">USBD serial number generator</a></td></tr>
<tr class="memdesc:group__app__usbd__serial__num"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Generate a standard USB serial number that is unique for each device. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__string__desc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__string__desc.html">USBD string descriptors</a></td></tr>
<tr class="memdesc:group__app__usbd__string__desc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> USBD string descriptor management. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__types"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__types.html">USB Device high level library variable types definition</a></td></tr>
<tr class="memdesc:group__app__usbd__types"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> All types used by <a class="el" href="group__app__usbd.html">USB Device high level library</a> are defined here. This helps to avoid cross referencing into types in different files. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__audio"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__audio.html">USB AUDIO class</a></td></tr>
<tr class="memdesc:group__app__usbd__audio"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by USB Audio class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__cdc__acm"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__cdc__acm.html">USB CDC ACM class</a></td></tr>
<tr class="memdesc:group__app__usbd__cdc__acm"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions and API used by CDC ACM class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__dummy"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__dummy.html">USB Dummy class</a></td></tr>
<tr class="memdesc:group__app__usbd__dummy"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by the USB Dummy class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__hid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__hid.html">USB HID class</a></td></tr>
<tr class="memdesc:group__app__usbd__hid"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with generic HID event data processing. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__msc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__msc.html">USB MSC class</a></td></tr>
<tr class="memdesc:group__app__usbd__msc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by the USB MSC class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__nrf__dfu__trigger"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__nrf__dfu__trigger.html">USB Nordic DFU Trigger class</a></td></tr>
<tr class="memdesc:group__app__usbd__nrf__dfu__trigger"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="whichnRF nRF52840">nRF52840 only:</span> Module with types, definitions, and API used by the USB Nordic DFU Trigger class. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__app__usbd__config"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd__config.html">USB Device library configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration passed to <a class="el" href="group__app__usbd.html#ga5b0ac80bcb0f2440027bf9173981c69f">app_usbd_init</a>.  <a href="structapp__usbd__config__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga28ea89712a7d3450b6e0101a04e120e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga28ea89712a7d3450b6e0101a04e120e5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga28ea89712a7d3450b6e0101a04e120e5">APP_USBD_SOF_MAX</a>&#160;&#160;&#160;2047</td></tr>
<tr class="memdesc:ga28ea89712a7d3450b6e0101a04e120e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highest value of Frame Number in SOF packets. <br/></td></tr>
<tr class="separator:ga28ea89712a7d3450b6e0101a04e120e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53a58649f9af2808b7f940895d7f984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab53a58649f9af2808b7f940895d7f984">APP_USBD_PROVIDE_SOF_TIMESTAMP</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gab53a58649f9af2808b7f940895d7f984"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if SOF timestamping is really provided.  <a href="#gab53a58649f9af2808b7f940895d7f984">More...</a><br/></td></tr>
<tr class="separator:gab53a58649f9af2808b7f940895d7f984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0efea3803bbee45e97441eab89dd08e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga0efea3803bbee45e97441eab89dd08e9">APP_USBD_SOF_HANDLING_NORMAL_QUEUE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga0efea3803bbee45e97441eab89dd08e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOF event handling modes.  <a href="#ga0efea3803bbee45e97441eab89dd08e9">More...</a><br/></td></tr>
<tr class="separator:ga0efea3803bbee45e97441eab89dd08e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc609b9a5a46b6872b17889eaa352df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7dc609b9a5a46b6872b17889eaa352df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga7dc609b9a5a46b6872b17889eaa352df">APP_USBD_SOF_HANDLING_COMPRESS_QUEUE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga7dc609b9a5a46b6872b17889eaa352df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress SOF events. <br/></td></tr>
<tr class="separator:ga7dc609b9a5a46b6872b17889eaa352df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a56703230823437f6018c1a197c1f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga64a56703230823437f6018c1a197c1f1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga64a56703230823437f6018c1a197c1f1">APP_USBD_SOF_HANDLING_INTERRUPT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga64a56703230823437f6018c1a197c1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle SOF events in interrupt. <br/></td></tr>
<tr class="separator:ga64a56703230823437f6018c1a197c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3eb5ec6ab8356d971f3e6413d1ee033f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga3eb5ec6ab8356d971f3e6413d1ee033f">app_usbd_sof_timestamp_get</a> (void)</td></tr>
<tr class="memdesc:ga3eb5ec6ab8356d971f3e6413d1ee033f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timestamp function for the logger.  <a href="#ga3eb5ec6ab8356d971f3e6413d1ee033f">More...</a><br/></td></tr>
<tr class="separator:ga3eb5ec6ab8356d971f3e6413d1ee033f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga5b0ac80bcb0f2440027bf9173981c69f">app_usbd_init</a> (<a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a> const *p_config)</td></tr>
<tr class="memdesc:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB library initialization.  <a href="#ga5b0ac80bcb0f2440027bf9173981c69f">More...</a><br/></td></tr>
<tr class="separator:ga5b0ac80bcb0f2440027bf9173981c69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3acabd753250ab7e071c0a2c166b983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab3acabd753250ab7e071c0a2c166b983">app_usbd_uninit</a> (void)</td></tr>
<tr class="memdesc:gab3acabd753250ab7e071c0a2c166b983"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB library un-initialization.  <a href="#gab3acabd753250ab7e071c0a2c166b983">More...</a><br/></td></tr>
<tr class="separator:gab3acabd753250ab7e071c0a2c166b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fa704d1cff404b56af41222db2979fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga5fa704d1cff404b56af41222db2979fa">app_usbd_power_events_enable</a> (void)</td></tr>
<tr class="memdesc:ga5fa704d1cff404b56af41222db2979fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to start USB related power events processing.  <a href="#ga5fa704d1cff404b56af41222db2979fa">More...</a><br/></td></tr>
<tr class="separator:ga5fa704d1cff404b56af41222db2979fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gae6b56c2e6aa8074c9fa5bcf61cc608dd">app_usbd_enable</a> (void)</td></tr>
<tr class="memdesc:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable USBD.  <a href="#gae6b56c2e6aa8074c9fa5bcf61cc608dd">More...</a><br/></td></tr>
<tr class="separator:gae6b56c2e6aa8074c9fa5bcf61cc608dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadc4e96cec2f00e65f8a6718735d0d20a">app_usbd_disable</a> (void)</td></tr>
<tr class="memdesc:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable USBD.  <a href="#gadc4e96cec2f00e65f8a6718735d0d20a">More...</a><br/></td></tr>
<tr class="separator:gadc4e96cec2f00e65f8a6718735d0d20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13088881a90703a337690c3eb4c930ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga13088881a90703a337690c3eb4c930ee">app_usbd_start</a> (void)</td></tr>
<tr class="memdesc:ga13088881a90703a337690c3eb4c930ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request USBD to start.  <a href="#ga13088881a90703a337690c3eb4c930ee">More...</a><br/></td></tr>
<tr class="separator:ga13088881a90703a337690c3eb4c930ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a55fed9bf7cb28106c45f58257942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga36a55fed9bf7cb28106c45f58257942d">app_usbd_stop</a> (void)</td></tr>
<tr class="memdesc:ga36a55fed9bf7cb28106c45f58257942d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB.  <a href="#ga36a55fed9bf7cb28106c45f58257942d">More...</a><br/></td></tr>
<tr class="separator:ga36a55fed9bf7cb28106c45f58257942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a0a454061f4c4a977817e1407bec8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga80a0a454061f4c4a977817e1407bec8d">app_usbd_suspend_req</a> (void)</td></tr>
<tr class="memdesc:ga80a0a454061f4c4a977817e1407bec8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request library to suspend.  <a href="#ga80a0a454061f4c4a977817e1407bec8d">More...</a><br/></td></tr>
<tr class="separator:ga80a0a454061f4c4a977817e1407bec8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac878231bc00d806eacbd7d09ef6739f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gac878231bc00d806eacbd7d09ef6739f4">app_usbd_wakeup_req</a> (void)</td></tr>
<tr class="memdesc:gac878231bc00d806eacbd7d09ef6739f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request library to wake-up.  <a href="#gac878231bc00d806eacbd7d09ef6739f4">More...</a><br/></td></tr>
<tr class="separator:gac878231bc00d806eacbd7d09ef6739f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1d3d0f99eefc5046e1143f5568d0dd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad1d3d0f99eefc5046e1143f5568d0dd9">app_usbd_active_check</a> (void)</td></tr>
<tr class="memdesc:gad1d3d0f99eefc5046e1143f5568d0dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information whether there is an active connection.  <a href="#gad1d3d0f99eefc5046e1143f5568d0dd9">More...</a><br/></td></tr>
<tr class="separator:gad1d3d0f99eefc5046e1143f5568d0dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga7d2c8cbc33d6efed1ab6b396a852b33e">app_usbd_event_execute</a> (<a class="el" href="unionapp__usbd__internal__evt__t.html">app_usbd_internal_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD event processor.  <a href="#ga7d2c8cbc33d6efed1ab6b396a852b33e">More...</a><br/></td></tr>
<tr class="separator:ga7d2c8cbc33d6efed1ab6b396a852b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadaa7b1f5326fb702c363bac1b78d3e92">app_usbd_event_queue_process</a> (void)</td></tr>
<tr class="memdesc:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that process events from the queue.  <a href="#gadaa7b1f5326fb702c363bac1b78d3e92">More...</a><br/></td></tr>
<tr class="separator:gadaa7b1f5326fb702c363bac1b78d3e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa376e2f9825be7630d54eb14383327ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaa376e2f9825be7630d54eb14383327ce">app_usbd_class_append</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:gaa376e2f9825be7630d54eb14383327ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add class instance.  <a href="#gaa376e2f9825be7630d54eb14383327ce">More...</a><br/></td></tr>
<tr class="separator:gaa376e2f9825be7630d54eb14383327ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd105c7b99a5220f31019063477c2855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855">app_usbd_class_remove</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:gadd105c7b99a5220f31019063477c2855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove class instance.  <a href="#gadd105c7b99a5220f31019063477c2855">More...</a><br/></td></tr>
<tr class="separator:gadd105c7b99a5220f31019063477c2855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f415ae33e0acfd6a99835effa87642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad1f415ae33e0acfd6a99835effa87642">app_usbd_class_remove_all</a> (void)</td></tr>
<tr class="memdesc:gad1f415ae33e0acfd6a99835effa87642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all class instances.  <a href="#gad1f415ae33e0acfd6a99835effa87642">More...</a><br/></td></tr>
<tr class="separator:gad1f415ae33e0acfd6a99835effa87642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3044dbc144aded985b0154741982b3a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga3044dbc144aded985b0154741982b3a7">app_usbd_ep_handler_set</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst, <a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="group__app__usbd__types.html#ga400c0df37a662783894f63925b25d02a">app_usbd_ep_event_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga3044dbc144aded985b0154741982b3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change endpoint handler.  <a href="#ga3044dbc144aded985b0154741982b3a7">More...</a><br/></td></tr>
<tr class="separator:ga3044dbc144aded985b0154741982b3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30e0168554e973012996eed9daa89019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019">app_usbd_class_sof_register</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:ga30e0168554e973012996eed9daa89019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register class instance as the one that requires SOF events.  <a href="#ga30e0168554e973012996eed9daa89019">More...</a><br/></td></tr>
<tr class="separator:ga30e0168554e973012996eed9daa89019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0e716ee754a178d3be4446bef2d77a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga2d0e716ee754a178d3be4446bef2d77a">app_usbd_class_sof_unregister</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:ga2d0e716ee754a178d3be4446bef2d77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister class instance from SOF processing instances list.  <a href="#ga2d0e716ee754a178d3be4446bef2d77a">More...</a><br/></td></tr>
<tr class="separator:ga2d0e716ee754a178d3be4446bef2d77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b0636d086529ff814bd30a89eed81e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga4b0636d086529ff814bd30a89eed81e4">app_usbd_class_sof_interrupt_register</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst, <a class="el" href="group__app__usbd__types.html#ga3e26444465d5acc61aadad71fb403ae4">app_usbd_sof_interrupt_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga4b0636d086529ff814bd30a89eed81e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register class instance as the one that requires SOF events in interrupt.  <a href="#ga4b0636d086529ff814bd30a89eed81e4">More...</a><br/></td></tr>
<tr class="separator:ga4b0636d086529ff814bd30a89eed81e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79410f36025ee1907db451170f46d4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaa79410f36025ee1907db451170f46d4f">app_usbd_class_sof_interrupt_unregister</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *p_cinst)</td></tr>
<tr class="memdesc:gaa79410f36025ee1907db451170f46d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister class instance from SOF processing in interrupt instances list.  <a href="#gaa79410f36025ee1907db451170f46d4f">More...</a><br/></td></tr>
<tr class="separator:gaa79410f36025ee1907db451170f46d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8729bd01008c1b17609501acd69f1337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga8729bd01008c1b17609501acd69f1337">app_usbd_class_rwu_register</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst)</td></tr>
<tr class="memdesc:ga8729bd01008c1b17609501acd69f1337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register class on remote wake-up feature.  <a href="#ga8729bd01008c1b17609501acd69f1337">More...</a><br/></td></tr>
<tr class="separator:ga8729bd01008c1b17609501acd69f1337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a8544a25d12016dd5cd67f16c8e446"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad2a8544a25d12016dd5cd67f16c8e446">app_usbd_class_rwu_unregister</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst)</td></tr>
<tr class="memdesc:gad2a8544a25d12016dd5cd67f16c8e446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister class from remote wake-up feature.  <a href="#gad2a8544a25d12016dd5cd67f16c8e446">More...</a><br/></td></tr>
<tr class="separator:gad2a8544a25d12016dd5cd67f16c8e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50116d479b383778bdd3dd9fcfe67782"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga50116d479b383778bdd3dd9fcfe67782">app_usbd_class_rwu_enabled_check</a> (void)</td></tr>
<tr class="memdesc:ga50116d479b383778bdd3dd9fcfe67782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is any class with remote wakeup.  <a href="#ga50116d479b383778bdd3dd9fcfe67782">More...</a><br/></td></tr>
<tr class="separator:ga50116d479b383778bdd3dd9fcfe67782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe1d837fb44faa177064565c5bbba44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga8fe1d837fb44faa177064565c5bbba44">app_usbd_class_descriptor_find</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst, uint8_t desc_type, uint8_t desc_index, uint8_t *p_desc, size_t *p_desc_len)</td></tr>
<tr class="memdesc:ga8fe1d837fb44faa177064565c5bbba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a specified descriptor.  <a href="#ga8fe1d837fb44faa177064565c5bbba44">More...</a><br/></td></tr>
<tr class="separator:ga8fe1d837fb44faa177064565c5bbba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa11a8d92e9e6f678f618cfd5a0e5c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gadaa11a8d92e9e6f678f618cfd5a0e5c8">app_usbd_interface_ep_reset</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst, uint8_t iface)</td></tr>
<tr class="memdesc:gadaa11a8d92e9e6f678f618cfd5a0e5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard set interface request handle.  <a href="#gadaa11a8d92e9e6f678f618cfd5a0e5c8">More...</a><br/></td></tr>
<tr class="separator:gadaa11a8d92e9e6f678f618cfd5a0e5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320a6972138331c91c13a48265cf8b65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga320a6972138331c91c13a48265cf8b65">app_usbd_ep_enable</a> (<a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga320a6972138331c91c13a48265cf8b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable selected endpoint.  <a href="#ga320a6972138331c91c13a48265cf8b65">More...</a><br/></td></tr>
<tr class="separator:ga320a6972138331c91c13a48265cf8b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefc0eb4f47495f161cb7a9b9fd49050d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaefc0eb4f47495f161cb7a9b9fd49050d">app_usbd_ep_disable</a> (<a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gaefc0eb4f47495f161cb7a9b9fd49050d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable selected endpoint.  <a href="#gaefc0eb4f47495f161cb7a9b9fd49050d">More...</a><br/></td></tr>
<tr class="separator:gaefc0eb4f47495f161cb7a9b9fd49050d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b827b305860b38679f04c83a9b795fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga4b827b305860b38679f04c83a9b795fd">app_usbd_iface_find</a> (uint8_t iface, uint8_t *p_iface_idx)</td></tr>
<tr class="memdesc:ga4b827b305860b38679f04c83a9b795fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for selected interface.  <a href="#ga4b827b305860b38679f04c83a9b795fd">More...</a><br/></td></tr>
<tr class="separator:ga4b827b305860b38679f04c83a9b795fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf754f99ad83091360123daa162efa4be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaf754f99ad83091360123daa162efa4be">app_usbd_ep_transfer</a> (<a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="group__nrf__drv__usbd.html#gaf0aeebf03daaaedf6fa70ba26e813097">nrf_drv_usbd_transfer_t</a> const *const p_transfer)</td></tr>
<tr class="memdesc:gaf754f99ad83091360123daa162efa4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint transfer.  <a href="#gaf754f99ad83091360123daa162efa4be">More...</a><br/></td></tr>
<tr class="separator:gaf754f99ad83091360123daa162efa4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94a373371de6414575f70f690c22eab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gad94a373371de6414575f70f690c22eab">app_usbd_ep_handled_transfer</a> (<a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="group__nrf__drv__usbd.html#ga6ad3ba5b9aeeea67095b264ed8fb0738">nrf_drv_usbd_handler_desc_t</a> const *const p_handler)</td></tr>
<tr class="memdesc:gad94a373371de6414575f70f690c22eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up an endpoint handled transfer.  <a href="#gad94a373371de6414575f70f690c22eab">More...</a><br/></td></tr>
<tr class="separator:gad94a373371de6414575f70f690c22eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7306aef8ce88429cd278d17fc00cae92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga7306aef8ce88429cd278d17fc00cae92">app_usbd_iface_select</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst, uint8_t iface_idx, uint8_t alternate)</td></tr>
<tr class="memdesc:ga7306aef8ce88429cd278d17fc00cae92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select interface.  <a href="#ga7306aef8ce88429cd278d17fc00cae92">More...</a><br/></td></tr>
<tr class="separator:ga7306aef8ce88429cd278d17fc00cae92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68501dcf4c09af62236a03c95e0a02fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga68501dcf4c09af62236a03c95e0a02fb">app_usbd_iface_deselect</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst, uint8_t iface_idx)</td></tr>
<tr class="memdesc:ga68501dcf4c09af62236a03c95e0a02fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deselect interface.  <a href="#ga68501dcf4c09af62236a03c95e0a02fb">More...</a><br/></td></tr>
<tr class="separator:ga68501dcf4c09af62236a03c95e0a02fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga201ae28750c91809aa049ab94b35f57c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga201ae28750c91809aa049ab94b35f57c">app_usbd_iface_selection_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_inst, uint8_t iface_idx)</td></tr>
<tr class="memdesc:ga201ae28750c91809aa049ab94b35f57c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get selected interface.  <a href="#ga201ae28750c91809aa049ab94b35f57c">More...</a><br/></td></tr>
<tr class="separator:ga201ae28750c91809aa049ab94b35f57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c6dd69e62a3070339f3f727c0592cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga06c6dd69e62a3070339f3f727c0592cc">app_usbd_all_iface_select_0</a> (void)</td></tr>
<tr class="memdesc:ga06c6dd69e62a3070339f3f727c0592cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select alternate configuration 0 for all interfaces.  <a href="#ga06c6dd69e62a3070339f3f727c0592cc">More...</a><br/></td></tr>
<tr class="separator:ga06c6dd69e62a3070339f3f727c0592cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae463f5e3e9f0dc7d3deda25ae0f5c4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gae463f5e3e9f0dc7d3deda25ae0f5c4ad">app_usbd_all_iface_deselect</a> (void)</td></tr>
<tr class="memdesc:gae463f5e3e9f0dc7d3deda25ae0f5c4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deselect all interfaces.  <a href="#gae463f5e3e9f0dc7d3deda25ae0f5c4ad">More...</a><br/></td></tr>
<tr class="separator:gae463f5e3e9f0dc7d3deda25ae0f5c4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Iterate through classes lists</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp5d32e66acf3dcfa8984b7a04a042eeab"></a>Functions that helps to iterate through internally chained classes. </p>
</td></tr>
<tr class="memitem:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga077f1cd8183ae5dbe75d472bc21a3fa7">app_usbd_class_first_get</a> (void)</td></tr>
<tr class="memdesc:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first class instance in the list.  <a href="#ga077f1cd8183ae5dbe75d472bc21a3fa7">More...</a><br/></td></tr>
<tr class="separator:ga077f1cd8183ae5dbe75d472bc21a3fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> <br class="typebreak"/>
const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gae1148b331aedb38bd70f8fdf61b2c73e">app_usbd_class_next_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst)</td></tr>
<tr class="memdesc:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next instance in the list.  <a href="#gae1148b331aedb38bd70f8fdf61b2c73e">More...</a><br/></td></tr>
<tr class="separator:gae1148b331aedb38bd70f8fdf61b2c73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66079874e7a71aadc2d59fcd77a3415a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga66079874e7a71aadc2d59fcd77a3415a">app_usbd_class_sof_first_get</a> (void)</td></tr>
<tr class="memdesc:ga66079874e7a71aadc2d59fcd77a3415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first instance in SOF list.  <a href="#ga66079874e7a71aadc2d59fcd77a3415a">More...</a><br/></td></tr>
<tr class="separator:ga66079874e7a71aadc2d59fcd77a3415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> <br class="typebreak"/>
const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaf6af0d27465ce259f0e9ae06c0e342f7">app_usbd_class_sof_next_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst)</td></tr>
<tr class="memdesc:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next instance in the SOF list.  <a href="#gaf6af0d27465ce259f0e9ae06c0e342f7">More...</a><br/></td></tr>
<tr class="separator:gaf6af0d27465ce259f0e9ae06c0e342f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917f18803c6eb1f45d9c162362bfb850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga917f18803c6eb1f45d9c162362bfb850">app_usbd_class_sof_interrupt_first_get</a> (void)</td></tr>
<tr class="memdesc:ga917f18803c6eb1f45d9c162362bfb850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get first instance in SOF interrupt list.  <a href="#ga917f18803c6eb1f45d9c162362bfb850">More...</a><br/></td></tr>
<tr class="separator:ga917f18803c6eb1f45d9c162362bfb850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8635157597ea1d4b7e287e7fa646d574"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> <br class="typebreak"/>
const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga8635157597ea1d4b7e287e7fa646d574">app_usbd_class_sof_interrupt_next_get</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_cinst)</td></tr>
<tr class="memdesc:ga8635157597ea1d4b7e287e7fa646d574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next instance in the SOF interrupt list.  <a href="#ga8635157597ea1d4b7e287e7fa646d574">More...</a><br/></td></tr>
<tr class="separator:ga8635157597ea1d4b7e287e7fa646d574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Communicate with interfaces, endpoints and instances inside usbd library</h2></td></tr>
<tr class="memitem:gaf7befa648d0d5ef81cdf59db0a64ea9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gaf7befa648d0d5ef81cdf59db0a64ea9c">app_usbd_iface_call</a> (<a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const p_class_inst, uint8_t iface_idx, <a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gaf7befa648d0d5ef81cdf59db0a64ea9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call interface event handler.  <a href="#gaf7befa648d0d5ef81cdf59db0a64ea9c">More...</a><br/></td></tr>
<tr class="separator:gaf7befa648d0d5ef81cdf59db0a64ea9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b8dc3687095fca39b1711d53eaaa04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab6b8dc3687095fca39b1711d53eaaa04">app_usbd_ep_call</a> (<a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gab6b8dc3687095fca39b1711d53eaaa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call endpoint event handler.  <a href="#gab6b8dc3687095fca39b1711d53eaaa04">More...</a><br/></td></tr>
<tr class="separator:gab6b8dc3687095fca39b1711d53eaaa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67397463798b5bbc3030195ee7fdca92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#ga67397463798b5bbc3030195ee7fdca92">app_usbd_all_call</a> (<a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:ga67397463798b5bbc3030195ee7fdca92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary function that process event by every instance in the list.  <a href="#ga67397463798b5bbc3030195ee7fdca92">More...</a><br/></td></tr>
<tr class="separator:ga67397463798b5bbc3030195ee7fdca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37d21a790ed702538b0042cc5f6cda0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__app__usbd.html#gab37d21a790ed702538b0042cc5f6cda0">app_usbd_all_until_served_call</a> (<a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gab37d21a790ed702538b0042cc5f6cda0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call interface event handlers and stop when served.  <a href="#gab37d21a790ed702538b0042cc5f6cda0">More...</a><br/></td></tr>
<tr class="separator:gab37d21a790ed702538b0042cc5f6cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p><span class="whichnRF nRF52840">nRF52840 only:</span> Module for easy support for any USB device configuration. </p>
<p>This module manages class instances that would create the USB device, manages endpoints and interfaces transactions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab53a58649f9af2808b7f940895d7f984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_USBD_PROVIDE_SOF_TIMESTAMP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>True if SOF timestamping is really provided. </p>
<p>SOF timestamping is really provided if it was requested and if the logger is enabled. </p>

</div>
</div>
<a class="anchor" id="ga0efea3803bbee45e97441eab89dd08e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APP_USBD_SOF_HANDLING_NORMAL_QUEUE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SOF event handling modes. </p>
<p>Push SOF events into event queue. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad1d3d0f99eefc5046e1143f5568d0dd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_active_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information whether there is an active connection. </p>
<p>Function to check if the communication with the bus is possible.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The bus is active. </td></tr>
    <tr><td class="paramname">false</td><td>There is no connection or bus is suspended. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga67397463798b5bbc3030195ee7fdca92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_all_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Auxiliary function that process event by every instance in the list. </p>
<p>This function ignores the result of called handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_event</td><td>Event to pass to every instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae463f5e3e9f0dc7d3deda25ae0f5c4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_all_iface_deselect </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deselect all interfaces. </p>
<p>Auxiliary function to disable all interfaces. </p>

</div>
</div>
<a class="anchor" id="ga06c6dd69e62a3070339f3f727c0592cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_all_iface_select_0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select alternate configuration 0 for all interfaces. </p>
<p>Auxiliary function that clears settings for all interfaces leaving them enabled. </p>

</div>
</div>
<a class="anchor" id="gab37d21a790ed702538b0042cc5f6cda0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_all_until_served_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call interface event handlers and stop when served. </p>
<p>Call event handlers from instances as long as we get result different than <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138">NRF_ERROR_NOT_SUPPORTED</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status or <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#gaacf52836cc3860c5ffd4e129f725f138">NRF_ERROR_NOT_SUPPORTED</a> if none of instances in the list can support given event. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa376e2f9825be7630d54eb14383327ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add class instance. </p>
<p>This function connects given instance into internal class instance chain and into all required endpoints. The instance event handler would be connected into endpoint by default, but this can be overwritten by <a class="el" href="group__app__usbd.html#ga3044dbc144aded985b0154741982b3a7">app_usbd_ep_handler_set</a>.</p>
<p>After successful attachment <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a6861c224b4be018a8963c1c8eb4bbbab">APP_USBD_EVT_INST_APPEND</a> would be passed to class instance.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_cinst</td><td>Instance to connect. Chain data would be written into writable instance data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance successfully added. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Endpoint(s) not available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fe1d837fb44faa177064565c5bbba44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_descriptor_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>desc_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_desc_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a specified descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Class instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc_type</td><td>Descriptor type <a class="el" href="group__app__usbd__descriptor.html#gacb04dcfed93a75a47681e93e38a4adff">app_usbd_descriptor_t</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc_index</td><td>Descriptor index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>Pointer to escriptor. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc_len</td><td>Length of descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code <a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Descriptor successfully found. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Descriptor not found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga077f1cd8183ae5dbe75d472bc21a3fa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_first_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first class instance in the list. </p>
<p>Get first instance from the list of active class instances. That instance may be used then in <a class="el" href="group__app__usbd.html#gae1148b331aedb38bd70f8fdf61b2c73e">app_usbd_class_next_get</a> function.</p>
<dl class="section return"><dt>Returns</dt><dd>First instance in the list or NULL if there are no instances available. </dd></dl>

</div>
</div>
<a class="anchor" id="gae1148b331aedb38bd70f8fdf61b2c73e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_next_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next instance in the list. </p>
<p>Get the next instance from the list of active instances. Used to iterate through all instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>The current instance from with next one is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next instance to the given one or NULL if there is no more instances in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd105c7b99a5220f31019063477c2855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove class instance. </p>
<p>Instance is removed from instance chain. Instance and event handlers are removed also from endpoints. Endpoints used by by the class instance are left disabled.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance pointer to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance successfully removed. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Instance not found in the instance chain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad1f415ae33e0acfd6a99835effa87642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_remove_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all class instances. </p>
<p>This function basically calls <a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855">app_usbd_class_remove</a> on instances chain as long as there is any element left.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#gadd105c7b99a5220f31019063477c2855" title="Remove class instance.">app_usbd_class_remove</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Is should always return <a class="elRef" doxygen="tag_s212_offline.tag:../s212/" href="../s212/group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a>. Any error value returned would mean there is an error inside the library. </dd></dl>

</div>
</div>
<a class="anchor" id="ga50116d479b383778bdd3dd9fcfe67782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_class_rwu_enabled_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is any class with remote wakeup. </p>
<p>The function checks internal registered class with remote wakeup counter.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga8729bd01008c1b17609501acd69f1337" title="Register class on remote wake-up feature.">app_usbd_class_rwu_register</a>, <a class="el" href="group__app__usbd.html#gad2a8544a25d12016dd5cd67f16c8e446" title="Unregister class from remote wake-up feature.">app_usbd_class_rwu_unregister</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The remote wakeup functionality is required by some class instance. </td></tr>
    <tr><td class="paramname">false</td><td>There is no class instance that requires wakeup functionality. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8729bd01008c1b17609501acd69f1337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_rwu_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register class on remote wake-up feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inst</td><td>Instance of the class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance that requires remote wake-up registered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad2a8544a25d12016dd5cd67f16c8e446"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_rwu_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister class from remote wake-up feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inst</td><td>Instance of the class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance that requires remote wake-up removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga66079874e7a71aadc2d59fcd77a3415a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_first_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first instance in SOF list. </p>
<p>Start iteration through the list of instances that require SOF event processing.</p>
<dl class="section return"><dt>Returns</dt><dd>First instance in the list or NULL if the list is empty.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga077f1cd8183ae5dbe75d472bc21a3fa7" title="Get first class instance in the list.">app_usbd_class_first_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga917f18803c6eb1f45d9c162362bfb850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_interrupt_first_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get first instance in SOF interrupt list. </p>
<p>Start iteration through the list of instances that require SOF processing in interrupt.</p>
<dl class="section return"><dt>Returns</dt><dd>First instance in the list or NULL if the list is empty.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga077f1cd8183ae5dbe75d472bc21a3fa7" title="Get first class instance in the list.">app_usbd_class_first_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8635157597ea1d4b7e287e7fa646d574"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_interrupt_next_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next instance in the SOF interrupt list. </p>
<p>Get the next instance from the list of instances requiring SOF processing in interrupt. Used to iterate through all SOF instances that have SOF handlers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>The current instance from with next one is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next instance to the given one or NULL if there is no more instances in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b0636d086529ff814bd30a89eed81e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_interrupt_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__app__usbd__types.html#ga3e26444465d5acc61aadad71fb403ae4">app_usbd_sof_interrupt_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register class instance as the one that requires SOF events in interrupt. </p>
<p>This function should be called in reaction on APP_USBD_EVT_INST_APPEND event. Connect the class instance to the list of instances that requires SOF processing. If none of the appended instances requires SOF event - it is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance that requires SOF event. </td></tr>
    <tr><td class="paramname">handler</td><td>Handler to SOF event</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#gaa79410f36025ee1907db451170f46d4f" title="Unregister class instance from SOF processing in interrupt instances list.">app_usbd_class_sof_interrupt_unregister</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa79410f36025ee1907db451170f46d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_interrupt_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister class instance from SOF processing in interrupt instances list. </p>
<p>Every class that calls <a class="el" href="group__app__usbd.html#ga4b0636d086529ff814bd30a89eed81e4">app_usbd_class_sof_interrupt_register</a> have to call also unregistering function in reaction to <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a13857bc6299925773250eae65fe1e866">APP_USBD_EVT_INST_REMOVE</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance to be unregistered from SOF processing in interrupt list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing in interrupt list. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Instance not found in the SOF processing in interrupt list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga4b0636d086529ff814bd30a89eed81e4" title="Register class instance as the one that requires SOF events in interrupt.">app_usbd_class_sof_interrupt_register</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6af0d27465ce259f0e9ae06c0e342f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_class_sof_next_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get next instance in the SOF list. </p>
<p>Get the next instance from the list of instances requiring SOF event processing. Used to iterate through all SOF instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>The current instance from with next one is required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Next instance to the given one or NULL if there is no more instances in the list. </dd></dl>

</div>
</div>
<a class="anchor" id="ga30e0168554e973012996eed9daa89019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register class instance as the one that requires SOF events. </p>
<p>This function should be called in reaction on APP_USBD_EVT_INST_APPEND event. Connect the class instance to the list of instances that requires SOF processing. If none of the appended instances requires SOF event - it is disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance that requires SOF event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga2d0e716ee754a178d3be4446bef2d77a" title="Unregister class instance from SOF processing instances list.">app_usbd_class_sof_unregister</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d0e716ee754a178d3be4446bef2d77a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_class_sof_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister class instance from SOF processing instances list. </p>
<p>Every class that calls <a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019">app_usbd_class_sof_register</a> have to call also unregistering function in reaction to <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a13857bc6299925773250eae65fe1e866">APP_USBD_EVT_INST_REMOVE</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_cinst</td><td>Instance to be unregistered from SOF event processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Instance linked into SOF processing list. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>Instance not found in the SOF processing list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#ga30e0168554e973012996eed9daa89019" title="Register class instance as the one that requires SOF events.">app_usbd_class_sof_register</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadc4e96cec2f00e65f8a6718735d0d20a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable USBD. </p>
<p>Disabled USDB peripheral cannot be accessed but also stops requesting High Frequency clock and releases power regulator.</p>
<dl class="section note"><dt>Note</dt><dd>This function cannot be called when USB is started. Stop it first. </dd></dl>

</div>
</div>
<a class="anchor" id="gae6b56c2e6aa8074c9fa5bcf61cc608dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable USBD. </p>
<p>USBD is enabled. Since now the high frequency clock may be requested when USB RESET would be detected. </p>

</div>
</div>
<a class="anchor" id="gab6b8dc3687095fca39b1711d53eaaa04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call endpoint event handler. </p>
<p>Call event handler for the selected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>

</div>
</div>
<a class="anchor" id="gaefc0eb4f47495f161cb7a9b9fd49050d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_ep_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable selected endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga320a6972138331c91c13a48265cf8b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_ep_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable selected endpoint. </p>
<p>Selected endpoint is enabled and cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad94a373371de6414575f70f690c22eab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_handled_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#ga6ad3ba5b9aeeea67095b264ed8fb0738">nrf_drv_usbd_handler_desc_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up an endpoint handled transfer. </p>
<p>Configures a transfer handled by the feedback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number. </td></tr>
    <tr><td class="paramname">p_handler</td><td>Function called when the next chunk of data is requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>The state of the USB device does not allow data transfer on the endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values returned by <a class="el" href="group__nrf__drv__usbd.html#ga55ba050ff87e01f7012a5a9fae3f2951">nrf_drv_usbd_ep_handled_transfer</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3044dbc144aded985b0154741982b3a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_handler_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__app__usbd__types.html#ga400c0df37a662783894f63925b25d02a">app_usbd_ep_event_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change endpoint handler. </p>
<p>This function may be called for the endpoint only if the class instance is already properly attached by the <a class="el" href="group__app__usbd.html#gaa376e2f9825be7630d54eb14383327ce">app_usbd_class_append</a> function.</p>
<p>The endpoint event handler function can be only overwritten by the class instance that was connected into the endpoint.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be called after USBD library is initialized but still disabled. Assertion would be generated otherwise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Instance of a class that wish to set new event handler. It has to match currently configured instance for the selected endpoint. In other situation error would be returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint address to configure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler function to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>New handler successfully set </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>p_cinst is not the same as currently set for the endpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf754f99ad83091360123daa162efa4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_ep_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrfx__usbd.html#ga46bdf8fe1cd3f46fbfac2ccbbba4c148">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaf0aeebf03daaaedf6fa70ba26e813097">nrf_drv_usbd_transfer_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number. </td></tr>
    <tr><td class="paramname">p_transfer</td><td>Description of the transfer to be performed. The direction of the transfer is determined by the endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>The state of the USB device does not allow data transfer on the endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values returned by <a class="el" href="group__nrf__drv__usbd.html#ga20ea0ca100ba53a4741e2682c8bfe06a">nrf_drv_usbd_ep_transfer</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__app__usbd.html#gad94a373371de6414575f70f690c22eab" title="Set up an endpoint handled transfer.">app_usbd_ep_handled_transfer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d2c8cbc33d6efed1ab6b396a852b33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_event_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__internal__evt__t.html">app_usbd_internal_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD event processor. </p>
<p>Function to be called on each event to be processed by the library. </p>

</div>
</div>
<a class="anchor" id="gadaa7b1f5326fb702c363bac1b78d3e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_event_queue_process </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function that process events from the queue. </p>
<dl class="section note"><dt>Note</dt><dd>This function calls <a class="el" href="group__app__usbd.html#ga7d2c8cbc33d6efed1ab6b396a852b33e">app_usbd_event_execute</a> internally.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Event was processed. </td></tr>
    <tr><td class="paramname">false</td><td>The event queue is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7befa648d0d5ef81cdf59db0a64ea9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_iface_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_class_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionapp__usbd__complex__evt__t.html">app_usbd_complex_evt_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call interface event handler. </p>
<p>Call event handler for selected interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_class_inst</td><td>Class instance that holds selected interface. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface_idx</td><td>Index of the interface in class structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event structure to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operation status. </dd></dl>

</div>
</div>
<a class="anchor" id="ga68501dcf4c09af62236a03c95e0a02fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_iface_deselect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deselect interface. </p>
<p>Disable the given interface. This function calls class interface deselection function or default interface selection function.</p>
<p>After calling this function all the endpoints from the interface have to be disabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_inst</td><td>Instance of the class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface_idx</td><td>Index of the interface inside class structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b827b305860b38679f04c83a9b795fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const* app_usbd_iface_find </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_iface_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for selected interface. </p>
<p>Function searches for the given interface number and returns the class that contains it. Optionally it can return interface index inside class instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Interface number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_iface_idx</td><td>Pointer to a variable that would hold interface index inside returned class instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the class structure that cointain given interface or NULL if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7306aef8ce88429cd278d17fc00cae92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_iface_select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>alternate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select interface. </p>
<p>Select the given interface. This function calls class interface selection function or default interface selection function.</p>
<p>After calling this function interface should be functional.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_inst</td><td>Instance of the class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface_idx</td><td>Index of the interface inside class structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternate</td><td>Alternate setting that should be selected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga201ae28750c91809aa049ab94b35f57c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t app_usbd_iface_selection_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get selected interface. </p>
<p>Function retieves currently selected interface. If the class contains <a class="el" href="structapp__usbd__class__methods__t.html#af1a49c1cba47fec4837a9bb36bd73127">app_usbd_class_methods_t::iface_selection_get</a> it is called. It it does not contain this function this function would return default, 0 value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inst</td><td>Instance of the class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface_idx</td><td>Index of the interface inside class structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Selected alternate interface setting. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b0ac80bcb0f2440027bf9173981c69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__config__t.html">app_usbd_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB library initialization. </p>
<p>Call this function before any configuration or class attachment. USBD peripheral would be ready to accept commands, and library would be ready, but it would not be connected to the bus. Call <a class="el" href="group__app__usbd.html#gae6b56c2e6aa8074c9fa5bcf61cc608dd">app_usbd_enable</a> to enable USBD communication with the host.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_config</td><td>Configuration. NULL pointer might be passed here and default configuration will be applied then. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadaa11a8d92e9e6f678f618cfd5a0e5c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_interface_ep_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapp__usbd__class__inst__t.html">app_usbd_class_inst_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cinst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>iface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard set interface request handle. </p>
<p>This function should be called when processing SET_INTERFACE request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_cinst</td><td>Instance of a class. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iface</td><td>Interface number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Standard error code.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Selected interface to reset has to be part of given class. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5fa704d1cff404b56af41222db2979fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_power_events_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to start USB related power events processing. </p>
<p>This function should be called after <a class="el" href="group__app__usbd.html#ga5b0ac80bcb0f2440027bf9173981c69f">app_usbd_init</a> and after all the required classes were appended (<a class="el" href="group__app__usbd.html#gaa376e2f9825be7630d54eb14383327ce">app_usbd_class_append</a>).</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Power events successfully initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>The state of the driver does not allow to enable the power events processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3eb5ec6ab8356d971f3e6413d1ee033f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t app_usbd_sof_timestamp_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timestamp function for the logger. </p>
<dl class="section return"><dt>Returns</dt><dd>Current frame number taken directly from the last processed SOF. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13088881a90703a337690c3eb4c930ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request USBD to start. </p>
<p>The function sends start request to the event queue. If the queue is enabled (<a class="el" href="group__app__usbd__config.html#gacf2cd19ac46de55f691b3bcc3ed74083">APP_USBD_CONFIG_EVENT_QUEUE_ENABLE</a>) it would be processed when the queue is processed. If queue is disabled it would be processed immediately inside this function. It means that if queue is disabled this function cannot be called from interrupt with priority higher than USB interrupt.</p>
<p>When start is processed it would:</p>
<ol type="1">
<li>Start library.</li>
<li>Enable interrupts.</li>
<li>Enable USB pull-ups.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>In some specific circumstances the library can be left not started and this function would silently exit. This may happen if some glitches appears on USB power line or if the plug was disconnected before whole starting process finishes. User would get the event from POWER peripheral then. Also no <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event would be generated to the classes and user event handler. For the safe code it is recommended to wait for <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event if anything has to be initialized after USB driver is started (just before enabling the interrupts). If library is properly started the <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331a207e0d15ef3951b9a647d3ab41703908">APP_USBD_EVT_STARTED</a> event passed to the user handler from this function body. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36a55fed9bf7cb28106c45f58257942d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop USB. </p>
<p>The function sends stop request to the event queue. If the queue is enabled (<a class="el" href="group__app__usbd__config.html#gacf2cd19ac46de55f691b3bcc3ed74083">APP_USBD_CONFIG_EVENT_QUEUE_ENABLE</a>) it would be processed when the queue is processed. If queue is disabled it would be processed immediately inside this function. It means that if queue is disabled this function cannot be called from interrupt with priority higher than USB interrupt.</p>
<p>When the event is processed interrupts and USB pull-ups are disabled. The peripheral itself is left enabled so it can be programmed, but a HOST sees it as a peripheral disconnection.</p>
<dl class="section note"><dt>Note</dt><dd>If the library is not started when this function is called it exits silently - also no <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331afbd9412ac094f05e4a23e99ce5e8ec80">APP_USBD_EVT_STOPPED</a> is generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a0a454061f4c4a977817e1407bec8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void app_usbd_suspend_req </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request library to suspend. </p>
<p>This function send suspend request to the event queue.</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called after <a class="el" href="group__app__usbd__types.html#ggae307a374b0c1a5fa6b9dc07fa517e331aa999a8dda6bb54847f07e1aafe7e5416">APP_USBD_EVT_DRV_SUSPEND</a> os received. Internal suspend request processing would give no effect if the bus is not in suspend state. </dd></dl>

</div>
</div>
<a class="anchor" id="gab3acabd753250ab7e071c0a2c166b983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__sdk__error.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> app_usbd_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB library un-initialization. </p>
<dl class="section note"><dt>Note</dt><dd>Currently not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="gac878231bc00d806eacbd7d09ef6739f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool app_usbd_wakeup_req </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request library to wake-up. </p>
<p>This function send wakeup request to the event queue.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this function does not mean that peripheral is active - the wakeup request is sent into message queue and needs to be processed.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Wakeup generation has been started. </td></tr>
    <tr><td class="paramname">false</td><td>No wakeup would be generated becouse it is disabled by the host. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="topicfooter">
<a href="mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback" id="maillink">Documentation feedback</a> | <a href="https://devzone.nordicsemi.com/questions/" target="_blank">Developer Zone</a> | <a href="http://response.nordicsemi.com/subscribe-to-our-newsletters" target="_blank">Subscribe</a> | Updated <span id="date"/>
<script>
var date = new Date("Mon Sep 14 2020" + " UTC");
document.getElementById("date").innerHTML = date.toJSON().slice(0, 10);
var url=window.location.href.split("?")[0];
var filename=url.substring(url.lastIndexOf('/')+1);
document.getElementById("maillink").href = "mailto:docfeedback@nordicsemi.no?subject=Documentation%20feedback"+decodeURIComponent("%26")+"body=File%20name%3A%20"+encodeURIComponent(filename);
</script>
</div>
</body>
</html>
